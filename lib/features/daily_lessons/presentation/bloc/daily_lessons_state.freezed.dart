// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'daily_lessons_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$VocabulariesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Vocabulary> vocabularies) loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Vocabulary> vocabularies)? loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Vocabulary> vocabularies)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VocabulariesInitial value) initial,
    required TResult Function(VocabulariesLoading value) loading,
    required TResult Function(VocabulariesLoaded value) loaded,
    required TResult Function(VocabulariesError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VocabulariesInitial value)? initial,
    TResult? Function(VocabulariesLoading value)? loading,
    TResult? Function(VocabulariesLoaded value)? loaded,
    TResult? Function(VocabulariesError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VocabulariesInitial value)? initial,
    TResult Function(VocabulariesLoading value)? loading,
    TResult Function(VocabulariesLoaded value)? loaded,
    TResult Function(VocabulariesError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VocabulariesStateCopyWith<$Res> {
  factory $VocabulariesStateCopyWith(
          VocabulariesState value, $Res Function(VocabulariesState) then) =
      _$VocabulariesStateCopyWithImpl<$Res, VocabulariesState>;
}

/// @nodoc
class _$VocabulariesStateCopyWithImpl<$Res, $Val extends VocabulariesState>
    implements $VocabulariesStateCopyWith<$Res> {
  _$VocabulariesStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$VocabulariesInitialImplCopyWith<$Res> {
  factory _$$VocabulariesInitialImplCopyWith(_$VocabulariesInitialImpl value,
          $Res Function(_$VocabulariesInitialImpl) then) =
      __$$VocabulariesInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$VocabulariesInitialImplCopyWithImpl<$Res>
    extends _$VocabulariesStateCopyWithImpl<$Res, _$VocabulariesInitialImpl>
    implements _$$VocabulariesInitialImplCopyWith<$Res> {
  __$$VocabulariesInitialImplCopyWithImpl(_$VocabulariesInitialImpl _value,
      $Res Function(_$VocabulariesInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$VocabulariesInitialImpl implements VocabulariesInitial {
  const _$VocabulariesInitialImpl();

  @override
  String toString() {
    return 'VocabulariesState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VocabulariesInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Vocabulary> vocabularies) loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Vocabulary> vocabularies)? loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Vocabulary> vocabularies)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VocabulariesInitial value) initial,
    required TResult Function(VocabulariesLoading value) loading,
    required TResult Function(VocabulariesLoaded value) loaded,
    required TResult Function(VocabulariesError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VocabulariesInitial value)? initial,
    TResult? Function(VocabulariesLoading value)? loading,
    TResult? Function(VocabulariesLoaded value)? loaded,
    TResult? Function(VocabulariesError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VocabulariesInitial value)? initial,
    TResult Function(VocabulariesLoading value)? loading,
    TResult Function(VocabulariesLoaded value)? loaded,
    TResult Function(VocabulariesError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class VocabulariesInitial implements VocabulariesState {
  const factory VocabulariesInitial() = _$VocabulariesInitialImpl;
}

/// @nodoc
abstract class _$$VocabulariesLoadingImplCopyWith<$Res> {
  factory _$$VocabulariesLoadingImplCopyWith(_$VocabulariesLoadingImpl value,
          $Res Function(_$VocabulariesLoadingImpl) then) =
      __$$VocabulariesLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$VocabulariesLoadingImplCopyWithImpl<$Res>
    extends _$VocabulariesStateCopyWithImpl<$Res, _$VocabulariesLoadingImpl>
    implements _$$VocabulariesLoadingImplCopyWith<$Res> {
  __$$VocabulariesLoadingImplCopyWithImpl(_$VocabulariesLoadingImpl _value,
      $Res Function(_$VocabulariesLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$VocabulariesLoadingImpl implements VocabulariesLoading {
  const _$VocabulariesLoadingImpl();

  @override
  String toString() {
    return 'VocabulariesState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VocabulariesLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Vocabulary> vocabularies) loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Vocabulary> vocabularies)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Vocabulary> vocabularies)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VocabulariesInitial value) initial,
    required TResult Function(VocabulariesLoading value) loading,
    required TResult Function(VocabulariesLoaded value) loaded,
    required TResult Function(VocabulariesError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VocabulariesInitial value)? initial,
    TResult? Function(VocabulariesLoading value)? loading,
    TResult? Function(VocabulariesLoaded value)? loaded,
    TResult? Function(VocabulariesError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VocabulariesInitial value)? initial,
    TResult Function(VocabulariesLoading value)? loading,
    TResult Function(VocabulariesLoaded value)? loaded,
    TResult Function(VocabulariesError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class VocabulariesLoading implements VocabulariesState {
  const factory VocabulariesLoading() = _$VocabulariesLoadingImpl;
}

/// @nodoc
abstract class _$$VocabulariesLoadedImplCopyWith<$Res> {
  factory _$$VocabulariesLoadedImplCopyWith(_$VocabulariesLoadedImpl value,
          $Res Function(_$VocabulariesLoadedImpl) then) =
      __$$VocabulariesLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Vocabulary> vocabularies});
}

/// @nodoc
class __$$VocabulariesLoadedImplCopyWithImpl<$Res>
    extends _$VocabulariesStateCopyWithImpl<$Res, _$VocabulariesLoadedImpl>
    implements _$$VocabulariesLoadedImplCopyWith<$Res> {
  __$$VocabulariesLoadedImplCopyWithImpl(_$VocabulariesLoadedImpl _value,
      $Res Function(_$VocabulariesLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vocabularies = null,
  }) {
    return _then(_$VocabulariesLoadedImpl(
      null == vocabularies
          ? _value._vocabularies
          : vocabularies // ignore: cast_nullable_to_non_nullable
              as List<Vocabulary>,
    ));
  }
}

/// @nodoc

class _$VocabulariesLoadedImpl implements VocabulariesLoaded {
  const _$VocabulariesLoadedImpl(final List<Vocabulary> vocabularies)
      : _vocabularies = vocabularies;

  final List<Vocabulary> _vocabularies;
  @override
  List<Vocabulary> get vocabularies {
    if (_vocabularies is EqualUnmodifiableListView) return _vocabularies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_vocabularies);
  }

  @override
  String toString() {
    return 'VocabulariesState.loaded(vocabularies: $vocabularies)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VocabulariesLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._vocabularies, _vocabularies));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_vocabularies));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VocabulariesLoadedImplCopyWith<_$VocabulariesLoadedImpl> get copyWith =>
      __$$VocabulariesLoadedImplCopyWithImpl<_$VocabulariesLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Vocabulary> vocabularies) loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(vocabularies);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Vocabulary> vocabularies)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(vocabularies);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Vocabulary> vocabularies)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(vocabularies);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VocabulariesInitial value) initial,
    required TResult Function(VocabulariesLoading value) loading,
    required TResult Function(VocabulariesLoaded value) loaded,
    required TResult Function(VocabulariesError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VocabulariesInitial value)? initial,
    TResult? Function(VocabulariesLoading value)? loading,
    TResult? Function(VocabulariesLoaded value)? loaded,
    TResult? Function(VocabulariesError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VocabulariesInitial value)? initial,
    TResult Function(VocabulariesLoading value)? loading,
    TResult Function(VocabulariesLoaded value)? loaded,
    TResult Function(VocabulariesError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class VocabulariesLoaded implements VocabulariesState {
  const factory VocabulariesLoaded(final List<Vocabulary> vocabularies) =
      _$VocabulariesLoadedImpl;

  List<Vocabulary> get vocabularies;
  @JsonKey(ignore: true)
  _$$VocabulariesLoadedImplCopyWith<_$VocabulariesLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$VocabulariesErrorImplCopyWith<$Res> {
  factory _$$VocabulariesErrorImplCopyWith(_$VocabulariesErrorImpl value,
          $Res Function(_$VocabulariesErrorImpl) then) =
      __$$VocabulariesErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$VocabulariesErrorImplCopyWithImpl<$Res>
    extends _$VocabulariesStateCopyWithImpl<$Res, _$VocabulariesErrorImpl>
    implements _$$VocabulariesErrorImplCopyWith<$Res> {
  __$$VocabulariesErrorImplCopyWithImpl(_$VocabulariesErrorImpl _value,
      $Res Function(_$VocabulariesErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$VocabulariesErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$VocabulariesErrorImpl implements VocabulariesError {
  const _$VocabulariesErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'VocabulariesState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VocabulariesErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VocabulariesErrorImplCopyWith<_$VocabulariesErrorImpl> get copyWith =>
      __$$VocabulariesErrorImplCopyWithImpl<_$VocabulariesErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Vocabulary> vocabularies) loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Vocabulary> vocabularies)? loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Vocabulary> vocabularies)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VocabulariesInitial value) initial,
    required TResult Function(VocabulariesLoading value) loading,
    required TResult Function(VocabulariesLoaded value) loaded,
    required TResult Function(VocabulariesError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VocabulariesInitial value)? initial,
    TResult? Function(VocabulariesLoading value)? loading,
    TResult? Function(VocabulariesLoaded value)? loaded,
    TResult? Function(VocabulariesError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VocabulariesInitial value)? initial,
    TResult Function(VocabulariesLoading value)? loading,
    TResult Function(VocabulariesLoaded value)? loaded,
    TResult Function(VocabulariesError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class VocabulariesError implements VocabulariesState {
  const factory VocabulariesError(final String message) =
      _$VocabulariesErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$VocabulariesErrorImplCopyWith<_$VocabulariesErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PhrasesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Phrase> phrases) loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Phrase> phrases)? loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Phrase> phrases)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PhrasesInitial value) initial,
    required TResult Function(PhrasesLoading value) loading,
    required TResult Function(PhrasesLoaded value) loaded,
    required TResult Function(PhrasesError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PhrasesInitial value)? initial,
    TResult? Function(PhrasesLoading value)? loading,
    TResult? Function(PhrasesLoaded value)? loaded,
    TResult? Function(PhrasesError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PhrasesInitial value)? initial,
    TResult Function(PhrasesLoading value)? loading,
    TResult Function(PhrasesLoaded value)? loaded,
    TResult Function(PhrasesError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PhrasesStateCopyWith<$Res> {
  factory $PhrasesStateCopyWith(
          PhrasesState value, $Res Function(PhrasesState) then) =
      _$PhrasesStateCopyWithImpl<$Res, PhrasesState>;
}

/// @nodoc
class _$PhrasesStateCopyWithImpl<$Res, $Val extends PhrasesState>
    implements $PhrasesStateCopyWith<$Res> {
  _$PhrasesStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PhrasesInitialImplCopyWith<$Res> {
  factory _$$PhrasesInitialImplCopyWith(_$PhrasesInitialImpl value,
          $Res Function(_$PhrasesInitialImpl) then) =
      __$$PhrasesInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PhrasesInitialImplCopyWithImpl<$Res>
    extends _$PhrasesStateCopyWithImpl<$Res, _$PhrasesInitialImpl>
    implements _$$PhrasesInitialImplCopyWith<$Res> {
  __$$PhrasesInitialImplCopyWithImpl(
      _$PhrasesInitialImpl _value, $Res Function(_$PhrasesInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PhrasesInitialImpl implements PhrasesInitial {
  const _$PhrasesInitialImpl();

  @override
  String toString() {
    return 'PhrasesState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PhrasesInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Phrase> phrases) loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Phrase> phrases)? loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Phrase> phrases)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PhrasesInitial value) initial,
    required TResult Function(PhrasesLoading value) loading,
    required TResult Function(PhrasesLoaded value) loaded,
    required TResult Function(PhrasesError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PhrasesInitial value)? initial,
    TResult? Function(PhrasesLoading value)? loading,
    TResult? Function(PhrasesLoaded value)? loaded,
    TResult? Function(PhrasesError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PhrasesInitial value)? initial,
    TResult Function(PhrasesLoading value)? loading,
    TResult Function(PhrasesLoaded value)? loaded,
    TResult Function(PhrasesError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class PhrasesInitial implements PhrasesState {
  const factory PhrasesInitial() = _$PhrasesInitialImpl;
}

/// @nodoc
abstract class _$$PhrasesLoadingImplCopyWith<$Res> {
  factory _$$PhrasesLoadingImplCopyWith(_$PhrasesLoadingImpl value,
          $Res Function(_$PhrasesLoadingImpl) then) =
      __$$PhrasesLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PhrasesLoadingImplCopyWithImpl<$Res>
    extends _$PhrasesStateCopyWithImpl<$Res, _$PhrasesLoadingImpl>
    implements _$$PhrasesLoadingImplCopyWith<$Res> {
  __$$PhrasesLoadingImplCopyWithImpl(
      _$PhrasesLoadingImpl _value, $Res Function(_$PhrasesLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PhrasesLoadingImpl implements PhrasesLoading {
  const _$PhrasesLoadingImpl();

  @override
  String toString() {
    return 'PhrasesState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PhrasesLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Phrase> phrases) loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Phrase> phrases)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Phrase> phrases)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PhrasesInitial value) initial,
    required TResult Function(PhrasesLoading value) loading,
    required TResult Function(PhrasesLoaded value) loaded,
    required TResult Function(PhrasesError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PhrasesInitial value)? initial,
    TResult? Function(PhrasesLoading value)? loading,
    TResult? Function(PhrasesLoaded value)? loaded,
    TResult? Function(PhrasesError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PhrasesInitial value)? initial,
    TResult Function(PhrasesLoading value)? loading,
    TResult Function(PhrasesLoaded value)? loaded,
    TResult Function(PhrasesError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class PhrasesLoading implements PhrasesState {
  const factory PhrasesLoading() = _$PhrasesLoadingImpl;
}

/// @nodoc
abstract class _$$PhrasesLoadedImplCopyWith<$Res> {
  factory _$$PhrasesLoadedImplCopyWith(
          _$PhrasesLoadedImpl value, $Res Function(_$PhrasesLoadedImpl) then) =
      __$$PhrasesLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Phrase> phrases});
}

/// @nodoc
class __$$PhrasesLoadedImplCopyWithImpl<$Res>
    extends _$PhrasesStateCopyWithImpl<$Res, _$PhrasesLoadedImpl>
    implements _$$PhrasesLoadedImplCopyWith<$Res> {
  __$$PhrasesLoadedImplCopyWithImpl(
      _$PhrasesLoadedImpl _value, $Res Function(_$PhrasesLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? phrases = null,
  }) {
    return _then(_$PhrasesLoadedImpl(
      null == phrases
          ? _value._phrases
          : phrases // ignore: cast_nullable_to_non_nullable
              as List<Phrase>,
    ));
  }
}

/// @nodoc

class _$PhrasesLoadedImpl implements PhrasesLoaded {
  const _$PhrasesLoadedImpl(final List<Phrase> phrases) : _phrases = phrases;

  final List<Phrase> _phrases;
  @override
  List<Phrase> get phrases {
    if (_phrases is EqualUnmodifiableListView) return _phrases;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_phrases);
  }

  @override
  String toString() {
    return 'PhrasesState.loaded(phrases: $phrases)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PhrasesLoadedImpl &&
            const DeepCollectionEquality().equals(other._phrases, _phrases));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_phrases));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PhrasesLoadedImplCopyWith<_$PhrasesLoadedImpl> get copyWith =>
      __$$PhrasesLoadedImplCopyWithImpl<_$PhrasesLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Phrase> phrases) loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(phrases);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Phrase> phrases)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(phrases);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Phrase> phrases)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(phrases);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PhrasesInitial value) initial,
    required TResult Function(PhrasesLoading value) loading,
    required TResult Function(PhrasesLoaded value) loaded,
    required TResult Function(PhrasesError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PhrasesInitial value)? initial,
    TResult? Function(PhrasesLoading value)? loading,
    TResult? Function(PhrasesLoaded value)? loaded,
    TResult? Function(PhrasesError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PhrasesInitial value)? initial,
    TResult Function(PhrasesLoading value)? loading,
    TResult Function(PhrasesLoaded value)? loaded,
    TResult Function(PhrasesError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class PhrasesLoaded implements PhrasesState {
  const factory PhrasesLoaded(final List<Phrase> phrases) = _$PhrasesLoadedImpl;

  List<Phrase> get phrases;
  @JsonKey(ignore: true)
  _$$PhrasesLoadedImplCopyWith<_$PhrasesLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PhrasesErrorImplCopyWith<$Res> {
  factory _$$PhrasesErrorImplCopyWith(
          _$PhrasesErrorImpl value, $Res Function(_$PhrasesErrorImpl) then) =
      __$$PhrasesErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$PhrasesErrorImplCopyWithImpl<$Res>
    extends _$PhrasesStateCopyWithImpl<$Res, _$PhrasesErrorImpl>
    implements _$$PhrasesErrorImplCopyWith<$Res> {
  __$$PhrasesErrorImplCopyWithImpl(
      _$PhrasesErrorImpl _value, $Res Function(_$PhrasesErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$PhrasesErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PhrasesErrorImpl implements PhrasesError {
  const _$PhrasesErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'PhrasesState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PhrasesErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PhrasesErrorImplCopyWith<_$PhrasesErrorImpl> get copyWith =>
      __$$PhrasesErrorImplCopyWithImpl<_$PhrasesErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Phrase> phrases) loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Phrase> phrases)? loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Phrase> phrases)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PhrasesInitial value) initial,
    required TResult Function(PhrasesLoading value) loading,
    required TResult Function(PhrasesLoaded value) loaded,
    required TResult Function(PhrasesError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PhrasesInitial value)? initial,
    TResult? Function(PhrasesLoading value)? loading,
    TResult? Function(PhrasesLoaded value)? loaded,
    TResult? Function(PhrasesError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PhrasesInitial value)? initial,
    TResult Function(PhrasesLoading value)? loading,
    TResult Function(PhrasesLoaded value)? loaded,
    TResult Function(PhrasesError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PhrasesError implements PhrasesState {
  const factory PhrasesError(final String message) = _$PhrasesErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$PhrasesErrorImplCopyWith<_$PhrasesErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UserPreferencesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(UserPreferences preferences) loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(UserPreferences preferences)? loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(UserPreferences preferences)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserPreferencesInitial value) initial,
    required TResult Function(UserPreferencesLoading value) loading,
    required TResult Function(UserPreferencesLoaded value) loaded,
    required TResult Function(UserPreferencesError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserPreferencesInitial value)? initial,
    TResult? Function(UserPreferencesLoading value)? loading,
    TResult? Function(UserPreferencesLoaded value)? loaded,
    TResult? Function(UserPreferencesError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserPreferencesInitial value)? initial,
    TResult Function(UserPreferencesLoading value)? loading,
    TResult Function(UserPreferencesLoaded value)? loaded,
    TResult Function(UserPreferencesError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserPreferencesStateCopyWith<$Res> {
  factory $UserPreferencesStateCopyWith(UserPreferencesState value,
          $Res Function(UserPreferencesState) then) =
      _$UserPreferencesStateCopyWithImpl<$Res, UserPreferencesState>;
}

/// @nodoc
class _$UserPreferencesStateCopyWithImpl<$Res,
        $Val extends UserPreferencesState>
    implements $UserPreferencesStateCopyWith<$Res> {
  _$UserPreferencesStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserPreferencesInitialImplCopyWith<$Res> {
  factory _$$UserPreferencesInitialImplCopyWith(
          _$UserPreferencesInitialImpl value,
          $Res Function(_$UserPreferencesInitialImpl) then) =
      __$$UserPreferencesInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserPreferencesInitialImplCopyWithImpl<$Res>
    extends _$UserPreferencesStateCopyWithImpl<$Res,
        _$UserPreferencesInitialImpl>
    implements _$$UserPreferencesInitialImplCopyWith<$Res> {
  __$$UserPreferencesInitialImplCopyWithImpl(
      _$UserPreferencesInitialImpl _value,
      $Res Function(_$UserPreferencesInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserPreferencesInitialImpl implements UserPreferencesInitial {
  const _$UserPreferencesInitialImpl();

  @override
  String toString() {
    return 'UserPreferencesState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserPreferencesInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(UserPreferences preferences) loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(UserPreferences preferences)? loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(UserPreferences preferences)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserPreferencesInitial value) initial,
    required TResult Function(UserPreferencesLoading value) loading,
    required TResult Function(UserPreferencesLoaded value) loaded,
    required TResult Function(UserPreferencesError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserPreferencesInitial value)? initial,
    TResult? Function(UserPreferencesLoading value)? loading,
    TResult? Function(UserPreferencesLoaded value)? loaded,
    TResult? Function(UserPreferencesError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserPreferencesInitial value)? initial,
    TResult Function(UserPreferencesLoading value)? loading,
    TResult Function(UserPreferencesLoaded value)? loaded,
    TResult Function(UserPreferencesError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class UserPreferencesInitial implements UserPreferencesState {
  const factory UserPreferencesInitial() = _$UserPreferencesInitialImpl;
}

/// @nodoc
abstract class _$$UserPreferencesLoadingImplCopyWith<$Res> {
  factory _$$UserPreferencesLoadingImplCopyWith(
          _$UserPreferencesLoadingImpl value,
          $Res Function(_$UserPreferencesLoadingImpl) then) =
      __$$UserPreferencesLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserPreferencesLoadingImplCopyWithImpl<$Res>
    extends _$UserPreferencesStateCopyWithImpl<$Res,
        _$UserPreferencesLoadingImpl>
    implements _$$UserPreferencesLoadingImplCopyWith<$Res> {
  __$$UserPreferencesLoadingImplCopyWithImpl(
      _$UserPreferencesLoadingImpl _value,
      $Res Function(_$UserPreferencesLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserPreferencesLoadingImpl implements UserPreferencesLoading {
  const _$UserPreferencesLoadingImpl();

  @override
  String toString() {
    return 'UserPreferencesState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserPreferencesLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(UserPreferences preferences) loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(UserPreferences preferences)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(UserPreferences preferences)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserPreferencesInitial value) initial,
    required TResult Function(UserPreferencesLoading value) loading,
    required TResult Function(UserPreferencesLoaded value) loaded,
    required TResult Function(UserPreferencesError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserPreferencesInitial value)? initial,
    TResult? Function(UserPreferencesLoading value)? loading,
    TResult? Function(UserPreferencesLoaded value)? loaded,
    TResult? Function(UserPreferencesError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserPreferencesInitial value)? initial,
    TResult Function(UserPreferencesLoading value)? loading,
    TResult Function(UserPreferencesLoaded value)? loaded,
    TResult Function(UserPreferencesError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class UserPreferencesLoading implements UserPreferencesState {
  const factory UserPreferencesLoading() = _$UserPreferencesLoadingImpl;
}

/// @nodoc
abstract class _$$UserPreferencesLoadedImplCopyWith<$Res> {
  factory _$$UserPreferencesLoadedImplCopyWith(
          _$UserPreferencesLoadedImpl value,
          $Res Function(_$UserPreferencesLoadedImpl) then) =
      __$$UserPreferencesLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UserPreferences preferences});
}

/// @nodoc
class __$$UserPreferencesLoadedImplCopyWithImpl<$Res>
    extends _$UserPreferencesStateCopyWithImpl<$Res,
        _$UserPreferencesLoadedImpl>
    implements _$$UserPreferencesLoadedImplCopyWith<$Res> {
  __$$UserPreferencesLoadedImplCopyWithImpl(_$UserPreferencesLoadedImpl _value,
      $Res Function(_$UserPreferencesLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? preferences = null,
  }) {
    return _then(_$UserPreferencesLoadedImpl(
      null == preferences
          ? _value.preferences
          : preferences // ignore: cast_nullable_to_non_nullable
              as UserPreferences,
    ));
  }
}

/// @nodoc

class _$UserPreferencesLoadedImpl implements UserPreferencesLoaded {
  const _$UserPreferencesLoadedImpl(this.preferences);

  @override
  final UserPreferences preferences;

  @override
  String toString() {
    return 'UserPreferencesState.loaded(preferences: $preferences)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserPreferencesLoadedImpl &&
            (identical(other.preferences, preferences) ||
                other.preferences == preferences));
  }

  @override
  int get hashCode => Object.hash(runtimeType, preferences);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserPreferencesLoadedImplCopyWith<_$UserPreferencesLoadedImpl>
      get copyWith => __$$UserPreferencesLoadedImplCopyWithImpl<
          _$UserPreferencesLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(UserPreferences preferences) loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(preferences);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(UserPreferences preferences)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(preferences);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(UserPreferences preferences)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(preferences);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserPreferencesInitial value) initial,
    required TResult Function(UserPreferencesLoading value) loading,
    required TResult Function(UserPreferencesLoaded value) loaded,
    required TResult Function(UserPreferencesError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserPreferencesInitial value)? initial,
    TResult? Function(UserPreferencesLoading value)? loading,
    TResult? Function(UserPreferencesLoaded value)? loaded,
    TResult? Function(UserPreferencesError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserPreferencesInitial value)? initial,
    TResult Function(UserPreferencesLoading value)? loading,
    TResult Function(UserPreferencesLoaded value)? loaded,
    TResult Function(UserPreferencesError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class UserPreferencesLoaded implements UserPreferencesState {
  const factory UserPreferencesLoaded(final UserPreferences preferences) =
      _$UserPreferencesLoadedImpl;

  UserPreferences get preferences;
  @JsonKey(ignore: true)
  _$$UserPreferencesLoadedImplCopyWith<_$UserPreferencesLoadedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserPreferencesErrorImplCopyWith<$Res> {
  factory _$$UserPreferencesErrorImplCopyWith(_$UserPreferencesErrorImpl value,
          $Res Function(_$UserPreferencesErrorImpl) then) =
      __$$UserPreferencesErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$UserPreferencesErrorImplCopyWithImpl<$Res>
    extends _$UserPreferencesStateCopyWithImpl<$Res, _$UserPreferencesErrorImpl>
    implements _$$UserPreferencesErrorImplCopyWith<$Res> {
  __$$UserPreferencesErrorImplCopyWithImpl(_$UserPreferencesErrorImpl _value,
      $Res Function(_$UserPreferencesErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$UserPreferencesErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UserPreferencesErrorImpl implements UserPreferencesError {
  const _$UserPreferencesErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'UserPreferencesState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserPreferencesErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserPreferencesErrorImplCopyWith<_$UserPreferencesErrorImpl>
      get copyWith =>
          __$$UserPreferencesErrorImplCopyWithImpl<_$UserPreferencesErrorImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(UserPreferences preferences) loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(UserPreferences preferences)? loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(UserPreferences preferences)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserPreferencesInitial value) initial,
    required TResult Function(UserPreferencesLoading value) loading,
    required TResult Function(UserPreferencesLoaded value) loaded,
    required TResult Function(UserPreferencesError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserPreferencesInitial value)? initial,
    TResult? Function(UserPreferencesLoading value)? loading,
    TResult? Function(UserPreferencesLoaded value)? loaded,
    TResult? Function(UserPreferencesError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserPreferencesInitial value)? initial,
    TResult Function(UserPreferencesLoading value)? loading,
    TResult Function(UserPreferencesLoaded value)? loaded,
    TResult Function(UserPreferencesError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class UserPreferencesError implements UserPreferencesState {
  const factory UserPreferencesError(final String message) =
      _$UserPreferencesErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$UserPreferencesErrorImplCopyWith<_$UserPreferencesErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UserAnalyticsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(Map<String, dynamic> analytics) loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(Map<String, dynamic> analytics)? loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(Map<String, dynamic> analytics)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserAnalyticsInitial value) initial,
    required TResult Function(UserAnalyticsLoading value) loading,
    required TResult Function(UserAnalyticsLoaded value) loaded,
    required TResult Function(UserAnalyticsError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserAnalyticsInitial value)? initial,
    TResult? Function(UserAnalyticsLoading value)? loading,
    TResult? Function(UserAnalyticsLoaded value)? loaded,
    TResult? Function(UserAnalyticsError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserAnalyticsInitial value)? initial,
    TResult Function(UserAnalyticsLoading value)? loading,
    TResult Function(UserAnalyticsLoaded value)? loaded,
    TResult Function(UserAnalyticsError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserAnalyticsStateCopyWith<$Res> {
  factory $UserAnalyticsStateCopyWith(
          UserAnalyticsState value, $Res Function(UserAnalyticsState) then) =
      _$UserAnalyticsStateCopyWithImpl<$Res, UserAnalyticsState>;
}

/// @nodoc
class _$UserAnalyticsStateCopyWithImpl<$Res, $Val extends UserAnalyticsState>
    implements $UserAnalyticsStateCopyWith<$Res> {
  _$UserAnalyticsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserAnalyticsInitialImplCopyWith<$Res> {
  factory _$$UserAnalyticsInitialImplCopyWith(_$UserAnalyticsInitialImpl value,
          $Res Function(_$UserAnalyticsInitialImpl) then) =
      __$$UserAnalyticsInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserAnalyticsInitialImplCopyWithImpl<$Res>
    extends _$UserAnalyticsStateCopyWithImpl<$Res, _$UserAnalyticsInitialImpl>
    implements _$$UserAnalyticsInitialImplCopyWith<$Res> {
  __$$UserAnalyticsInitialImplCopyWithImpl(_$UserAnalyticsInitialImpl _value,
      $Res Function(_$UserAnalyticsInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserAnalyticsInitialImpl implements UserAnalyticsInitial {
  const _$UserAnalyticsInitialImpl();

  @override
  String toString() {
    return 'UserAnalyticsState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserAnalyticsInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(Map<String, dynamic> analytics) loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(Map<String, dynamic> analytics)? loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(Map<String, dynamic> analytics)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserAnalyticsInitial value) initial,
    required TResult Function(UserAnalyticsLoading value) loading,
    required TResult Function(UserAnalyticsLoaded value) loaded,
    required TResult Function(UserAnalyticsError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserAnalyticsInitial value)? initial,
    TResult? Function(UserAnalyticsLoading value)? loading,
    TResult? Function(UserAnalyticsLoaded value)? loaded,
    TResult? Function(UserAnalyticsError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserAnalyticsInitial value)? initial,
    TResult Function(UserAnalyticsLoading value)? loading,
    TResult Function(UserAnalyticsLoaded value)? loaded,
    TResult Function(UserAnalyticsError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class UserAnalyticsInitial implements UserAnalyticsState {
  const factory UserAnalyticsInitial() = _$UserAnalyticsInitialImpl;
}

/// @nodoc
abstract class _$$UserAnalyticsLoadingImplCopyWith<$Res> {
  factory _$$UserAnalyticsLoadingImplCopyWith(_$UserAnalyticsLoadingImpl value,
          $Res Function(_$UserAnalyticsLoadingImpl) then) =
      __$$UserAnalyticsLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserAnalyticsLoadingImplCopyWithImpl<$Res>
    extends _$UserAnalyticsStateCopyWithImpl<$Res, _$UserAnalyticsLoadingImpl>
    implements _$$UserAnalyticsLoadingImplCopyWith<$Res> {
  __$$UserAnalyticsLoadingImplCopyWithImpl(_$UserAnalyticsLoadingImpl _value,
      $Res Function(_$UserAnalyticsLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserAnalyticsLoadingImpl implements UserAnalyticsLoading {
  const _$UserAnalyticsLoadingImpl();

  @override
  String toString() {
    return 'UserAnalyticsState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserAnalyticsLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(Map<String, dynamic> analytics) loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(Map<String, dynamic> analytics)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(Map<String, dynamic> analytics)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserAnalyticsInitial value) initial,
    required TResult Function(UserAnalyticsLoading value) loading,
    required TResult Function(UserAnalyticsLoaded value) loaded,
    required TResult Function(UserAnalyticsError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserAnalyticsInitial value)? initial,
    TResult? Function(UserAnalyticsLoading value)? loading,
    TResult? Function(UserAnalyticsLoaded value)? loaded,
    TResult? Function(UserAnalyticsError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserAnalyticsInitial value)? initial,
    TResult Function(UserAnalyticsLoading value)? loading,
    TResult Function(UserAnalyticsLoaded value)? loaded,
    TResult Function(UserAnalyticsError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class UserAnalyticsLoading implements UserAnalyticsState {
  const factory UserAnalyticsLoading() = _$UserAnalyticsLoadingImpl;
}

/// @nodoc
abstract class _$$UserAnalyticsLoadedImplCopyWith<$Res> {
  factory _$$UserAnalyticsLoadedImplCopyWith(_$UserAnalyticsLoadedImpl value,
          $Res Function(_$UserAnalyticsLoadedImpl) then) =
      __$$UserAnalyticsLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Map<String, dynamic> analytics});
}

/// @nodoc
class __$$UserAnalyticsLoadedImplCopyWithImpl<$Res>
    extends _$UserAnalyticsStateCopyWithImpl<$Res, _$UserAnalyticsLoadedImpl>
    implements _$$UserAnalyticsLoadedImplCopyWith<$Res> {
  __$$UserAnalyticsLoadedImplCopyWithImpl(_$UserAnalyticsLoadedImpl _value,
      $Res Function(_$UserAnalyticsLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? analytics = null,
  }) {
    return _then(_$UserAnalyticsLoadedImpl(
      null == analytics
          ? _value._analytics
          : analytics // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc

class _$UserAnalyticsLoadedImpl implements UserAnalyticsLoaded {
  const _$UserAnalyticsLoadedImpl(final Map<String, dynamic> analytics)
      : _analytics = analytics;

  final Map<String, dynamic> _analytics;
  @override
  Map<String, dynamic> get analytics {
    if (_analytics is EqualUnmodifiableMapView) return _analytics;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_analytics);
  }

  @override
  String toString() {
    return 'UserAnalyticsState.loaded(analytics: $analytics)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserAnalyticsLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._analytics, _analytics));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_analytics));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserAnalyticsLoadedImplCopyWith<_$UserAnalyticsLoadedImpl> get copyWith =>
      __$$UserAnalyticsLoadedImplCopyWithImpl<_$UserAnalyticsLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(Map<String, dynamic> analytics) loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(analytics);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(Map<String, dynamic> analytics)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(analytics);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(Map<String, dynamic> analytics)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(analytics);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserAnalyticsInitial value) initial,
    required TResult Function(UserAnalyticsLoading value) loading,
    required TResult Function(UserAnalyticsLoaded value) loaded,
    required TResult Function(UserAnalyticsError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserAnalyticsInitial value)? initial,
    TResult? Function(UserAnalyticsLoading value)? loading,
    TResult? Function(UserAnalyticsLoaded value)? loaded,
    TResult? Function(UserAnalyticsError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserAnalyticsInitial value)? initial,
    TResult Function(UserAnalyticsLoading value)? loading,
    TResult Function(UserAnalyticsLoaded value)? loaded,
    TResult Function(UserAnalyticsError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class UserAnalyticsLoaded implements UserAnalyticsState {
  const factory UserAnalyticsLoaded(final Map<String, dynamic> analytics) =
      _$UserAnalyticsLoadedImpl;

  Map<String, dynamic> get analytics;
  @JsonKey(ignore: true)
  _$$UserAnalyticsLoadedImplCopyWith<_$UserAnalyticsLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserAnalyticsErrorImplCopyWith<$Res> {
  factory _$$UserAnalyticsErrorImplCopyWith(_$UserAnalyticsErrorImpl value,
          $Res Function(_$UserAnalyticsErrorImpl) then) =
      __$$UserAnalyticsErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$UserAnalyticsErrorImplCopyWithImpl<$Res>
    extends _$UserAnalyticsStateCopyWithImpl<$Res, _$UserAnalyticsErrorImpl>
    implements _$$UserAnalyticsErrorImplCopyWith<$Res> {
  __$$UserAnalyticsErrorImplCopyWithImpl(_$UserAnalyticsErrorImpl _value,
      $Res Function(_$UserAnalyticsErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$UserAnalyticsErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UserAnalyticsErrorImpl implements UserAnalyticsError {
  const _$UserAnalyticsErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'UserAnalyticsState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserAnalyticsErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserAnalyticsErrorImplCopyWith<_$UserAnalyticsErrorImpl> get copyWith =>
      __$$UserAnalyticsErrorImplCopyWithImpl<_$UserAnalyticsErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(Map<String, dynamic> analytics) loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(Map<String, dynamic> analytics)? loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(Map<String, dynamic> analytics)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserAnalyticsInitial value) initial,
    required TResult Function(UserAnalyticsLoading value) loading,
    required TResult Function(UserAnalyticsLoaded value) loaded,
    required TResult Function(UserAnalyticsError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserAnalyticsInitial value)? initial,
    TResult? Function(UserAnalyticsLoading value)? loading,
    TResult? Function(UserAnalyticsLoaded value)? loaded,
    TResult? Function(UserAnalyticsError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserAnalyticsInitial value)? initial,
    TResult Function(UserAnalyticsLoading value)? loading,
    TResult Function(UserAnalyticsLoaded value)? loaded,
    TResult Function(UserAnalyticsError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class UserAnalyticsError implements UserAnalyticsState {
  const factory UserAnalyticsError(final String message) =
      _$UserAnalyticsErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$UserAnalyticsErrorImplCopyWith<_$UserAnalyticsErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UserDataManagementState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDataManagementInitial value) initial,
    required TResult Function(UserDataManagementLoading value) loading,
    required TResult Function(UserDataManagementSuccess value) success,
    required TResult Function(UserDataManagementError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDataManagementInitial value)? initial,
    TResult? Function(UserDataManagementLoading value)? loading,
    TResult? Function(UserDataManagementSuccess value)? success,
    TResult? Function(UserDataManagementError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDataManagementInitial value)? initial,
    TResult Function(UserDataManagementLoading value)? loading,
    TResult Function(UserDataManagementSuccess value)? success,
    TResult Function(UserDataManagementError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserDataManagementStateCopyWith<$Res> {
  factory $UserDataManagementStateCopyWith(UserDataManagementState value,
          $Res Function(UserDataManagementState) then) =
      _$UserDataManagementStateCopyWithImpl<$Res, UserDataManagementState>;
}

/// @nodoc
class _$UserDataManagementStateCopyWithImpl<$Res,
        $Val extends UserDataManagementState>
    implements $UserDataManagementStateCopyWith<$Res> {
  _$UserDataManagementStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserDataManagementInitialImplCopyWith<$Res> {
  factory _$$UserDataManagementInitialImplCopyWith(
          _$UserDataManagementInitialImpl value,
          $Res Function(_$UserDataManagementInitialImpl) then) =
      __$$UserDataManagementInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserDataManagementInitialImplCopyWithImpl<$Res>
    extends _$UserDataManagementStateCopyWithImpl<$Res,
        _$UserDataManagementInitialImpl>
    implements _$$UserDataManagementInitialImplCopyWith<$Res> {
  __$$UserDataManagementInitialImplCopyWithImpl(
      _$UserDataManagementInitialImpl _value,
      $Res Function(_$UserDataManagementInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserDataManagementInitialImpl implements UserDataManagementInitial {
  const _$UserDataManagementInitialImpl();

  @override
  String toString() {
    return 'UserDataManagementState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserDataManagementInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDataManagementInitial value) initial,
    required TResult Function(UserDataManagementLoading value) loading,
    required TResult Function(UserDataManagementSuccess value) success,
    required TResult Function(UserDataManagementError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDataManagementInitial value)? initial,
    TResult? Function(UserDataManagementLoading value)? loading,
    TResult? Function(UserDataManagementSuccess value)? success,
    TResult? Function(UserDataManagementError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDataManagementInitial value)? initial,
    TResult Function(UserDataManagementLoading value)? loading,
    TResult Function(UserDataManagementSuccess value)? success,
    TResult Function(UserDataManagementError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class UserDataManagementInitial implements UserDataManagementState {
  const factory UserDataManagementInitial() = _$UserDataManagementInitialImpl;
}

/// @nodoc
abstract class _$$UserDataManagementLoadingImplCopyWith<$Res> {
  factory _$$UserDataManagementLoadingImplCopyWith(
          _$UserDataManagementLoadingImpl value,
          $Res Function(_$UserDataManagementLoadingImpl) then) =
      __$$UserDataManagementLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserDataManagementLoadingImplCopyWithImpl<$Res>
    extends _$UserDataManagementStateCopyWithImpl<$Res,
        _$UserDataManagementLoadingImpl>
    implements _$$UserDataManagementLoadingImplCopyWith<$Res> {
  __$$UserDataManagementLoadingImplCopyWithImpl(
      _$UserDataManagementLoadingImpl _value,
      $Res Function(_$UserDataManagementLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserDataManagementLoadingImpl implements UserDataManagementLoading {
  const _$UserDataManagementLoadingImpl();

  @override
  String toString() {
    return 'UserDataManagementState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserDataManagementLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDataManagementInitial value) initial,
    required TResult Function(UserDataManagementLoading value) loading,
    required TResult Function(UserDataManagementSuccess value) success,
    required TResult Function(UserDataManagementError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDataManagementInitial value)? initial,
    TResult? Function(UserDataManagementLoading value)? loading,
    TResult? Function(UserDataManagementSuccess value)? success,
    TResult? Function(UserDataManagementError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDataManagementInitial value)? initial,
    TResult Function(UserDataManagementLoading value)? loading,
    TResult Function(UserDataManagementSuccess value)? success,
    TResult Function(UserDataManagementError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class UserDataManagementLoading implements UserDataManagementState {
  const factory UserDataManagementLoading() = _$UserDataManagementLoadingImpl;
}

/// @nodoc
abstract class _$$UserDataManagementSuccessImplCopyWith<$Res> {
  factory _$$UserDataManagementSuccessImplCopyWith(
          _$UserDataManagementSuccessImpl value,
          $Res Function(_$UserDataManagementSuccessImpl) then) =
      __$$UserDataManagementSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserDataManagementSuccessImplCopyWithImpl<$Res>
    extends _$UserDataManagementStateCopyWithImpl<$Res,
        _$UserDataManagementSuccessImpl>
    implements _$$UserDataManagementSuccessImplCopyWith<$Res> {
  __$$UserDataManagementSuccessImplCopyWithImpl(
      _$UserDataManagementSuccessImpl _value,
      $Res Function(_$UserDataManagementSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserDataManagementSuccessImpl implements UserDataManagementSuccess {
  const _$UserDataManagementSuccessImpl();

  @override
  String toString() {
    return 'UserDataManagementState.success()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserDataManagementSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String message) error,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String message)? error,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDataManagementInitial value) initial,
    required TResult Function(UserDataManagementLoading value) loading,
    required TResult Function(UserDataManagementSuccess value) success,
    required TResult Function(UserDataManagementError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDataManagementInitial value)? initial,
    TResult? Function(UserDataManagementLoading value)? loading,
    TResult? Function(UserDataManagementSuccess value)? success,
    TResult? Function(UserDataManagementError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDataManagementInitial value)? initial,
    TResult Function(UserDataManagementLoading value)? loading,
    TResult Function(UserDataManagementSuccess value)? success,
    TResult Function(UserDataManagementError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class UserDataManagementSuccess implements UserDataManagementState {
  const factory UserDataManagementSuccess() = _$UserDataManagementSuccessImpl;
}

/// @nodoc
abstract class _$$UserDataManagementErrorImplCopyWith<$Res> {
  factory _$$UserDataManagementErrorImplCopyWith(
          _$UserDataManagementErrorImpl value,
          $Res Function(_$UserDataManagementErrorImpl) then) =
      __$$UserDataManagementErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$UserDataManagementErrorImplCopyWithImpl<$Res>
    extends _$UserDataManagementStateCopyWithImpl<$Res,
        _$UserDataManagementErrorImpl>
    implements _$$UserDataManagementErrorImplCopyWith<$Res> {
  __$$UserDataManagementErrorImplCopyWithImpl(
      _$UserDataManagementErrorImpl _value,
      $Res Function(_$UserDataManagementErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$UserDataManagementErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UserDataManagementErrorImpl implements UserDataManagementError {
  const _$UserDataManagementErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'UserDataManagementState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserDataManagementErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserDataManagementErrorImplCopyWith<_$UserDataManagementErrorImpl>
      get copyWith => __$$UserDataManagementErrorImplCopyWithImpl<
          _$UserDataManagementErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDataManagementInitial value) initial,
    required TResult Function(UserDataManagementLoading value) loading,
    required TResult Function(UserDataManagementSuccess value) success,
    required TResult Function(UserDataManagementError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDataManagementInitial value)? initial,
    TResult? Function(UserDataManagementLoading value)? loading,
    TResult? Function(UserDataManagementSuccess value)? success,
    TResult? Function(UserDataManagementError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDataManagementInitial value)? initial,
    TResult Function(UserDataManagementLoading value)? loading,
    TResult Function(UserDataManagementSuccess value)? success,
    TResult Function(UserDataManagementError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class UserDataManagementError implements UserDataManagementState {
  const factory UserDataManagementError(final String message) =
      _$UserDataManagementErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$UserDataManagementErrorImplCopyWith<_$UserDataManagementErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CourseCompletionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String pathId, int courseNumber) completed,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String pathId, int courseNumber)? completed,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String pathId, int courseNumber)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CourseCompletionInitial value) initial,
    required TResult Function(CourseCompletionLoading value) loading,
    required TResult Function(CourseCompletionCompleted value) completed,
    required TResult Function(CourseCompletionError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CourseCompletionInitial value)? initial,
    TResult? Function(CourseCompletionLoading value)? loading,
    TResult? Function(CourseCompletionCompleted value)? completed,
    TResult? Function(CourseCompletionError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CourseCompletionInitial value)? initial,
    TResult Function(CourseCompletionLoading value)? loading,
    TResult Function(CourseCompletionCompleted value)? completed,
    TResult Function(CourseCompletionError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CourseCompletionStateCopyWith<$Res> {
  factory $CourseCompletionStateCopyWith(CourseCompletionState value,
          $Res Function(CourseCompletionState) then) =
      _$CourseCompletionStateCopyWithImpl<$Res, CourseCompletionState>;
}

/// @nodoc
class _$CourseCompletionStateCopyWithImpl<$Res,
        $Val extends CourseCompletionState>
    implements $CourseCompletionStateCopyWith<$Res> {
  _$CourseCompletionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CourseCompletionInitialImplCopyWith<$Res> {
  factory _$$CourseCompletionInitialImplCopyWith(
          _$CourseCompletionInitialImpl value,
          $Res Function(_$CourseCompletionInitialImpl) then) =
      __$$CourseCompletionInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CourseCompletionInitialImplCopyWithImpl<$Res>
    extends _$CourseCompletionStateCopyWithImpl<$Res,
        _$CourseCompletionInitialImpl>
    implements _$$CourseCompletionInitialImplCopyWith<$Res> {
  __$$CourseCompletionInitialImplCopyWithImpl(
      _$CourseCompletionInitialImpl _value,
      $Res Function(_$CourseCompletionInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CourseCompletionInitialImpl implements CourseCompletionInitial {
  const _$CourseCompletionInitialImpl();

  @override
  String toString() {
    return 'CourseCompletionState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CourseCompletionInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String pathId, int courseNumber) completed,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String pathId, int courseNumber)? completed,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String pathId, int courseNumber)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CourseCompletionInitial value) initial,
    required TResult Function(CourseCompletionLoading value) loading,
    required TResult Function(CourseCompletionCompleted value) completed,
    required TResult Function(CourseCompletionError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CourseCompletionInitial value)? initial,
    TResult? Function(CourseCompletionLoading value)? loading,
    TResult? Function(CourseCompletionCompleted value)? completed,
    TResult? Function(CourseCompletionError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CourseCompletionInitial value)? initial,
    TResult Function(CourseCompletionLoading value)? loading,
    TResult Function(CourseCompletionCompleted value)? completed,
    TResult Function(CourseCompletionError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class CourseCompletionInitial implements CourseCompletionState {
  const factory CourseCompletionInitial() = _$CourseCompletionInitialImpl;
}

/// @nodoc
abstract class _$$CourseCompletionLoadingImplCopyWith<$Res> {
  factory _$$CourseCompletionLoadingImplCopyWith(
          _$CourseCompletionLoadingImpl value,
          $Res Function(_$CourseCompletionLoadingImpl) then) =
      __$$CourseCompletionLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CourseCompletionLoadingImplCopyWithImpl<$Res>
    extends _$CourseCompletionStateCopyWithImpl<$Res,
        _$CourseCompletionLoadingImpl>
    implements _$$CourseCompletionLoadingImplCopyWith<$Res> {
  __$$CourseCompletionLoadingImplCopyWithImpl(
      _$CourseCompletionLoadingImpl _value,
      $Res Function(_$CourseCompletionLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CourseCompletionLoadingImpl implements CourseCompletionLoading {
  const _$CourseCompletionLoadingImpl();

  @override
  String toString() {
    return 'CourseCompletionState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CourseCompletionLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String pathId, int courseNumber) completed,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String pathId, int courseNumber)? completed,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String pathId, int courseNumber)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CourseCompletionInitial value) initial,
    required TResult Function(CourseCompletionLoading value) loading,
    required TResult Function(CourseCompletionCompleted value) completed,
    required TResult Function(CourseCompletionError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CourseCompletionInitial value)? initial,
    TResult? Function(CourseCompletionLoading value)? loading,
    TResult? Function(CourseCompletionCompleted value)? completed,
    TResult? Function(CourseCompletionError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CourseCompletionInitial value)? initial,
    TResult Function(CourseCompletionLoading value)? loading,
    TResult Function(CourseCompletionCompleted value)? completed,
    TResult Function(CourseCompletionError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class CourseCompletionLoading implements CourseCompletionState {
  const factory CourseCompletionLoading() = _$CourseCompletionLoadingImpl;
}

/// @nodoc
abstract class _$$CourseCompletionCompletedImplCopyWith<$Res> {
  factory _$$CourseCompletionCompletedImplCopyWith(
          _$CourseCompletionCompletedImpl value,
          $Res Function(_$CourseCompletionCompletedImpl) then) =
      __$$CourseCompletionCompletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String pathId, int courseNumber});
}

/// @nodoc
class __$$CourseCompletionCompletedImplCopyWithImpl<$Res>
    extends _$CourseCompletionStateCopyWithImpl<$Res,
        _$CourseCompletionCompletedImpl>
    implements _$$CourseCompletionCompletedImplCopyWith<$Res> {
  __$$CourseCompletionCompletedImplCopyWithImpl(
      _$CourseCompletionCompletedImpl _value,
      $Res Function(_$CourseCompletionCompletedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pathId = null,
    Object? courseNumber = null,
  }) {
    return _then(_$CourseCompletionCompletedImpl(
      pathId: null == pathId
          ? _value.pathId
          : pathId // ignore: cast_nullable_to_non_nullable
              as String,
      courseNumber: null == courseNumber
          ? _value.courseNumber
          : courseNumber // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$CourseCompletionCompletedImpl implements CourseCompletionCompleted {
  const _$CourseCompletionCompletedImpl(
      {required this.pathId, required this.courseNumber});

  @override
  final String pathId;
  @override
  final int courseNumber;

  @override
  String toString() {
    return 'CourseCompletionState.completed(pathId: $pathId, courseNumber: $courseNumber)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CourseCompletionCompletedImpl &&
            (identical(other.pathId, pathId) || other.pathId == pathId) &&
            (identical(other.courseNumber, courseNumber) ||
                other.courseNumber == courseNumber));
  }

  @override
  int get hashCode => Object.hash(runtimeType, pathId, courseNumber);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CourseCompletionCompletedImplCopyWith<_$CourseCompletionCompletedImpl>
      get copyWith => __$$CourseCompletionCompletedImplCopyWithImpl<
          _$CourseCompletionCompletedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String pathId, int courseNumber) completed,
    required TResult Function(String message) error,
  }) {
    return completed(pathId, courseNumber);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String pathId, int courseNumber)? completed,
    TResult? Function(String message)? error,
  }) {
    return completed?.call(pathId, courseNumber);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String pathId, int courseNumber)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(pathId, courseNumber);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CourseCompletionInitial value) initial,
    required TResult Function(CourseCompletionLoading value) loading,
    required TResult Function(CourseCompletionCompleted value) completed,
    required TResult Function(CourseCompletionError value) error,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CourseCompletionInitial value)? initial,
    TResult? Function(CourseCompletionLoading value)? loading,
    TResult? Function(CourseCompletionCompleted value)? completed,
    TResult? Function(CourseCompletionError value)? error,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CourseCompletionInitial value)? initial,
    TResult Function(CourseCompletionLoading value)? loading,
    TResult Function(CourseCompletionCompleted value)? completed,
    TResult Function(CourseCompletionError value)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class CourseCompletionCompleted implements CourseCompletionState {
  const factory CourseCompletionCompleted(
      {required final String pathId,
      required final int courseNumber}) = _$CourseCompletionCompletedImpl;

  String get pathId;
  int get courseNumber;
  @JsonKey(ignore: true)
  _$$CourseCompletionCompletedImplCopyWith<_$CourseCompletionCompletedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CourseCompletionErrorImplCopyWith<$Res> {
  factory _$$CourseCompletionErrorImplCopyWith(
          _$CourseCompletionErrorImpl value,
          $Res Function(_$CourseCompletionErrorImpl) then) =
      __$$CourseCompletionErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CourseCompletionErrorImplCopyWithImpl<$Res>
    extends _$CourseCompletionStateCopyWithImpl<$Res,
        _$CourseCompletionErrorImpl>
    implements _$$CourseCompletionErrorImplCopyWith<$Res> {
  __$$CourseCompletionErrorImplCopyWithImpl(_$CourseCompletionErrorImpl _value,
      $Res Function(_$CourseCompletionErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CourseCompletionErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CourseCompletionErrorImpl implements CourseCompletionError {
  const _$CourseCompletionErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'CourseCompletionState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CourseCompletionErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CourseCompletionErrorImplCopyWith<_$CourseCompletionErrorImpl>
      get copyWith => __$$CourseCompletionErrorImplCopyWithImpl<
          _$CourseCompletionErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String pathId, int courseNumber) completed,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String pathId, int courseNumber)? completed,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String pathId, int courseNumber)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CourseCompletionInitial value) initial,
    required TResult Function(CourseCompletionLoading value) loading,
    required TResult Function(CourseCompletionCompleted value) completed,
    required TResult Function(CourseCompletionError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CourseCompletionInitial value)? initial,
    TResult? Function(CourseCompletionLoading value)? loading,
    TResult? Function(CourseCompletionCompleted value)? completed,
    TResult? Function(CourseCompletionError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CourseCompletionInitial value)? initial,
    TResult Function(CourseCompletionLoading value)? loading,
    TResult Function(CourseCompletionCompleted value)? completed,
    TResult Function(CourseCompletionError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class CourseCompletionError implements CourseCompletionState {
  const factory CourseCompletionError(final String message) =
      _$CourseCompletionErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$CourseCompletionErrorImplCopyWith<_$CourseCompletionErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DailyLessonsState {
  VocabulariesState get vocabularies => throw _privateConstructorUsedError;
  PhrasesState get phrases => throw _privateConstructorUsedError;
  UserPreferencesState get userPreferences =>
      throw _privateConstructorUsedError;
  UserAnalyticsState get analytics => throw _privateConstructorUsedError;
  UserDataManagementState get dataManagement =>
      throw _privateConstructorUsedError;
  CourseCompletionState get courseCompletion =>
      throw _privateConstructorUsedError;
  bool get isRefreshing => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DailyLessonsStateCopyWith<DailyLessonsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DailyLessonsStateCopyWith<$Res> {
  factory $DailyLessonsStateCopyWith(
          DailyLessonsState value, $Res Function(DailyLessonsState) then) =
      _$DailyLessonsStateCopyWithImpl<$Res, DailyLessonsState>;
  @useResult
  $Res call(
      {VocabulariesState vocabularies,
      PhrasesState phrases,
      UserPreferencesState userPreferences,
      UserAnalyticsState analytics,
      UserDataManagementState dataManagement,
      CourseCompletionState courseCompletion,
      bool isRefreshing});

  $VocabulariesStateCopyWith<$Res> get vocabularies;
  $PhrasesStateCopyWith<$Res> get phrases;
  $UserPreferencesStateCopyWith<$Res> get userPreferences;
  $UserAnalyticsStateCopyWith<$Res> get analytics;
  $UserDataManagementStateCopyWith<$Res> get dataManagement;
  $CourseCompletionStateCopyWith<$Res> get courseCompletion;
}

/// @nodoc
class _$DailyLessonsStateCopyWithImpl<$Res, $Val extends DailyLessonsState>
    implements $DailyLessonsStateCopyWith<$Res> {
  _$DailyLessonsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vocabularies = null,
    Object? phrases = null,
    Object? userPreferences = null,
    Object? analytics = null,
    Object? dataManagement = null,
    Object? courseCompletion = null,
    Object? isRefreshing = null,
  }) {
    return _then(_value.copyWith(
      vocabularies: null == vocabularies
          ? _value.vocabularies
          : vocabularies // ignore: cast_nullable_to_non_nullable
              as VocabulariesState,
      phrases: null == phrases
          ? _value.phrases
          : phrases // ignore: cast_nullable_to_non_nullable
              as PhrasesState,
      userPreferences: null == userPreferences
          ? _value.userPreferences
          : userPreferences // ignore: cast_nullable_to_non_nullable
              as UserPreferencesState,
      analytics: null == analytics
          ? _value.analytics
          : analytics // ignore: cast_nullable_to_non_nullable
              as UserAnalyticsState,
      dataManagement: null == dataManagement
          ? _value.dataManagement
          : dataManagement // ignore: cast_nullable_to_non_nullable
              as UserDataManagementState,
      courseCompletion: null == courseCompletion
          ? _value.courseCompletion
          : courseCompletion // ignore: cast_nullable_to_non_nullable
              as CourseCompletionState,
      isRefreshing: null == isRefreshing
          ? _value.isRefreshing
          : isRefreshing // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $VocabulariesStateCopyWith<$Res> get vocabularies {
    return $VocabulariesStateCopyWith<$Res>(_value.vocabularies, (value) {
      return _then(_value.copyWith(vocabularies: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PhrasesStateCopyWith<$Res> get phrases {
    return $PhrasesStateCopyWith<$Res>(_value.phrases, (value) {
      return _then(_value.copyWith(phrases: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserPreferencesStateCopyWith<$Res> get userPreferences {
    return $UserPreferencesStateCopyWith<$Res>(_value.userPreferences, (value) {
      return _then(_value.copyWith(userPreferences: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserAnalyticsStateCopyWith<$Res> get analytics {
    return $UserAnalyticsStateCopyWith<$Res>(_value.analytics, (value) {
      return _then(_value.copyWith(analytics: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserDataManagementStateCopyWith<$Res> get dataManagement {
    return $UserDataManagementStateCopyWith<$Res>(_value.dataManagement,
        (value) {
      return _then(_value.copyWith(dataManagement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CourseCompletionStateCopyWith<$Res> get courseCompletion {
    return $CourseCompletionStateCopyWith<$Res>(_value.courseCompletion,
        (value) {
      return _then(_value.copyWith(courseCompletion: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$DailyLessonsStateImplCopyWith<$Res>
    implements $DailyLessonsStateCopyWith<$Res> {
  factory _$$DailyLessonsStateImplCopyWith(_$DailyLessonsStateImpl value,
          $Res Function(_$DailyLessonsStateImpl) then) =
      __$$DailyLessonsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {VocabulariesState vocabularies,
      PhrasesState phrases,
      UserPreferencesState userPreferences,
      UserAnalyticsState analytics,
      UserDataManagementState dataManagement,
      CourseCompletionState courseCompletion,
      bool isRefreshing});

  @override
  $VocabulariesStateCopyWith<$Res> get vocabularies;
  @override
  $PhrasesStateCopyWith<$Res> get phrases;
  @override
  $UserPreferencesStateCopyWith<$Res> get userPreferences;
  @override
  $UserAnalyticsStateCopyWith<$Res> get analytics;
  @override
  $UserDataManagementStateCopyWith<$Res> get dataManagement;
  @override
  $CourseCompletionStateCopyWith<$Res> get courseCompletion;
}

/// @nodoc
class __$$DailyLessonsStateImplCopyWithImpl<$Res>
    extends _$DailyLessonsStateCopyWithImpl<$Res, _$DailyLessonsStateImpl>
    implements _$$DailyLessonsStateImplCopyWith<$Res> {
  __$$DailyLessonsStateImplCopyWithImpl(_$DailyLessonsStateImpl _value,
      $Res Function(_$DailyLessonsStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vocabularies = null,
    Object? phrases = null,
    Object? userPreferences = null,
    Object? analytics = null,
    Object? dataManagement = null,
    Object? courseCompletion = null,
    Object? isRefreshing = null,
  }) {
    return _then(_$DailyLessonsStateImpl(
      vocabularies: null == vocabularies
          ? _value.vocabularies
          : vocabularies // ignore: cast_nullable_to_non_nullable
              as VocabulariesState,
      phrases: null == phrases
          ? _value.phrases
          : phrases // ignore: cast_nullable_to_non_nullable
              as PhrasesState,
      userPreferences: null == userPreferences
          ? _value.userPreferences
          : userPreferences // ignore: cast_nullable_to_non_nullable
              as UserPreferencesState,
      analytics: null == analytics
          ? _value.analytics
          : analytics // ignore: cast_nullable_to_non_nullable
              as UserAnalyticsState,
      dataManagement: null == dataManagement
          ? _value.dataManagement
          : dataManagement // ignore: cast_nullable_to_non_nullable
              as UserDataManagementState,
      courseCompletion: null == courseCompletion
          ? _value.courseCompletion
          : courseCompletion // ignore: cast_nullable_to_non_nullable
              as CourseCompletionState,
      isRefreshing: null == isRefreshing
          ? _value.isRefreshing
          : isRefreshing // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$DailyLessonsStateImpl implements _DailyLessonsState {
  const _$DailyLessonsStateImpl(
      {required this.vocabularies,
      required this.phrases,
      required this.userPreferences,
      required this.analytics,
      required this.dataManagement,
      required this.courseCompletion,
      this.isRefreshing = false});

  @override
  final VocabulariesState vocabularies;
  @override
  final PhrasesState phrases;
  @override
  final UserPreferencesState userPreferences;
  @override
  final UserAnalyticsState analytics;
  @override
  final UserDataManagementState dataManagement;
  @override
  final CourseCompletionState courseCompletion;
  @override
  @JsonKey()
  final bool isRefreshing;

  @override
  String toString() {
    return 'DailyLessonsState(vocabularies: $vocabularies, phrases: $phrases, userPreferences: $userPreferences, analytics: $analytics, dataManagement: $dataManagement, courseCompletion: $courseCompletion, isRefreshing: $isRefreshing)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DailyLessonsStateImpl &&
            (identical(other.vocabularies, vocabularies) ||
                other.vocabularies == vocabularies) &&
            (identical(other.phrases, phrases) || other.phrases == phrases) &&
            (identical(other.userPreferences, userPreferences) ||
                other.userPreferences == userPreferences) &&
            (identical(other.analytics, analytics) ||
                other.analytics == analytics) &&
            (identical(other.dataManagement, dataManagement) ||
                other.dataManagement == dataManagement) &&
            (identical(other.courseCompletion, courseCompletion) ||
                other.courseCompletion == courseCompletion) &&
            (identical(other.isRefreshing, isRefreshing) ||
                other.isRefreshing == isRefreshing));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      vocabularies,
      phrases,
      userPreferences,
      analytics,
      dataManagement,
      courseCompletion,
      isRefreshing);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DailyLessonsStateImplCopyWith<_$DailyLessonsStateImpl> get copyWith =>
      __$$DailyLessonsStateImplCopyWithImpl<_$DailyLessonsStateImpl>(
          this, _$identity);
}

abstract class _DailyLessonsState implements DailyLessonsState {
  const factory _DailyLessonsState(
      {required final VocabulariesState vocabularies,
      required final PhrasesState phrases,
      required final UserPreferencesState userPreferences,
      required final UserAnalyticsState analytics,
      required final UserDataManagementState dataManagement,
      required final CourseCompletionState courseCompletion,
      final bool isRefreshing}) = _$DailyLessonsStateImpl;

  @override
  VocabulariesState get vocabularies;
  @override
  PhrasesState get phrases;
  @override
  UserPreferencesState get userPreferences;
  @override
  UserAnalyticsState get analytics;
  @override
  UserDataManagementState get dataManagement;
  @override
  CourseCompletionState get courseCompletion;
  @override
  bool get isRefreshing;
  @override
  @JsonKey(ignore: true)
  _$$DailyLessonsStateImplCopyWith<_$DailyLessonsStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
