// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'daily_lessons_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$VocabulariesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Vocabulary> vocabularies) loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Vocabulary> vocabularies)? loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Vocabulary> vocabularies)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VocabulariesInitial value) initial,
    required TResult Function(VocabulariesLoading value) loading,
    required TResult Function(VocabulariesLoaded value) loaded,
    required TResult Function(VocabulariesError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VocabulariesInitial value)? initial,
    TResult? Function(VocabulariesLoading value)? loading,
    TResult? Function(VocabulariesLoaded value)? loaded,
    TResult? Function(VocabulariesError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VocabulariesInitial value)? initial,
    TResult Function(VocabulariesLoading value)? loading,
    TResult Function(VocabulariesLoaded value)? loaded,
    TResult Function(VocabulariesError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VocabulariesStateCopyWith<$Res> {
  factory $VocabulariesStateCopyWith(
          VocabulariesState value, $Res Function(VocabulariesState) then) =
      _$VocabulariesStateCopyWithImpl<$Res, VocabulariesState>;
}

/// @nodoc
class _$VocabulariesStateCopyWithImpl<$Res, $Val extends VocabulariesState>
    implements $VocabulariesStateCopyWith<$Res> {
  _$VocabulariesStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of VocabulariesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$VocabulariesInitialImplCopyWith<$Res> {
  factory _$$VocabulariesInitialImplCopyWith(_$VocabulariesInitialImpl value,
          $Res Function(_$VocabulariesInitialImpl) then) =
      __$$VocabulariesInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$VocabulariesInitialImplCopyWithImpl<$Res>
    extends _$VocabulariesStateCopyWithImpl<$Res, _$VocabulariesInitialImpl>
    implements _$$VocabulariesInitialImplCopyWith<$Res> {
  __$$VocabulariesInitialImplCopyWithImpl(_$VocabulariesInitialImpl _value,
      $Res Function(_$VocabulariesInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of VocabulariesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$VocabulariesInitialImpl implements VocabulariesInitial {
  const _$VocabulariesInitialImpl();

  @override
  String toString() {
    return 'VocabulariesState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VocabulariesInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Vocabulary> vocabularies) loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Vocabulary> vocabularies)? loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Vocabulary> vocabularies)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VocabulariesInitial value) initial,
    required TResult Function(VocabulariesLoading value) loading,
    required TResult Function(VocabulariesLoaded value) loaded,
    required TResult Function(VocabulariesError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VocabulariesInitial value)? initial,
    TResult? Function(VocabulariesLoading value)? loading,
    TResult? Function(VocabulariesLoaded value)? loaded,
    TResult? Function(VocabulariesError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VocabulariesInitial value)? initial,
    TResult Function(VocabulariesLoading value)? loading,
    TResult Function(VocabulariesLoaded value)? loaded,
    TResult Function(VocabulariesError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class VocabulariesInitial implements VocabulariesState {
  const factory VocabulariesInitial() = _$VocabulariesInitialImpl;
}

/// @nodoc
abstract class _$$VocabulariesLoadingImplCopyWith<$Res> {
  factory _$$VocabulariesLoadingImplCopyWith(_$VocabulariesLoadingImpl value,
          $Res Function(_$VocabulariesLoadingImpl) then) =
      __$$VocabulariesLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$VocabulariesLoadingImplCopyWithImpl<$Res>
    extends _$VocabulariesStateCopyWithImpl<$Res, _$VocabulariesLoadingImpl>
    implements _$$VocabulariesLoadingImplCopyWith<$Res> {
  __$$VocabulariesLoadingImplCopyWithImpl(_$VocabulariesLoadingImpl _value,
      $Res Function(_$VocabulariesLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of VocabulariesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$VocabulariesLoadingImpl implements VocabulariesLoading {
  const _$VocabulariesLoadingImpl();

  @override
  String toString() {
    return 'VocabulariesState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VocabulariesLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Vocabulary> vocabularies) loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Vocabulary> vocabularies)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Vocabulary> vocabularies)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VocabulariesInitial value) initial,
    required TResult Function(VocabulariesLoading value) loading,
    required TResult Function(VocabulariesLoaded value) loaded,
    required TResult Function(VocabulariesError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VocabulariesInitial value)? initial,
    TResult? Function(VocabulariesLoading value)? loading,
    TResult? Function(VocabulariesLoaded value)? loaded,
    TResult? Function(VocabulariesError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VocabulariesInitial value)? initial,
    TResult Function(VocabulariesLoading value)? loading,
    TResult Function(VocabulariesLoaded value)? loaded,
    TResult Function(VocabulariesError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class VocabulariesLoading implements VocabulariesState {
  const factory VocabulariesLoading() = _$VocabulariesLoadingImpl;
}

/// @nodoc
abstract class _$$VocabulariesLoadedImplCopyWith<$Res> {
  factory _$$VocabulariesLoadedImplCopyWith(_$VocabulariesLoadedImpl value,
          $Res Function(_$VocabulariesLoadedImpl) then) =
      __$$VocabulariesLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Vocabulary> vocabularies});
}

/// @nodoc
class __$$VocabulariesLoadedImplCopyWithImpl<$Res>
    extends _$VocabulariesStateCopyWithImpl<$Res, _$VocabulariesLoadedImpl>
    implements _$$VocabulariesLoadedImplCopyWith<$Res> {
  __$$VocabulariesLoadedImplCopyWithImpl(_$VocabulariesLoadedImpl _value,
      $Res Function(_$VocabulariesLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of VocabulariesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vocabularies = null,
  }) {
    return _then(_$VocabulariesLoadedImpl(
      null == vocabularies
          ? _value._vocabularies
          : vocabularies // ignore: cast_nullable_to_non_nullable
              as List<Vocabulary>,
    ));
  }
}

/// @nodoc

class _$VocabulariesLoadedImpl implements VocabulariesLoaded {
  const _$VocabulariesLoadedImpl(final List<Vocabulary> vocabularies)
      : _vocabularies = vocabularies;

  final List<Vocabulary> _vocabularies;
  @override
  List<Vocabulary> get vocabularies {
    if (_vocabularies is EqualUnmodifiableListView) return _vocabularies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_vocabularies);
  }

  @override
  String toString() {
    return 'VocabulariesState.loaded(vocabularies: $vocabularies)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VocabulariesLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._vocabularies, _vocabularies));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_vocabularies));

  /// Create a copy of VocabulariesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VocabulariesLoadedImplCopyWith<_$VocabulariesLoadedImpl> get copyWith =>
      __$$VocabulariesLoadedImplCopyWithImpl<_$VocabulariesLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Vocabulary> vocabularies) loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(vocabularies);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Vocabulary> vocabularies)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(vocabularies);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Vocabulary> vocabularies)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(vocabularies);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VocabulariesInitial value) initial,
    required TResult Function(VocabulariesLoading value) loading,
    required TResult Function(VocabulariesLoaded value) loaded,
    required TResult Function(VocabulariesError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VocabulariesInitial value)? initial,
    TResult? Function(VocabulariesLoading value)? loading,
    TResult? Function(VocabulariesLoaded value)? loaded,
    TResult? Function(VocabulariesError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VocabulariesInitial value)? initial,
    TResult Function(VocabulariesLoading value)? loading,
    TResult Function(VocabulariesLoaded value)? loaded,
    TResult Function(VocabulariesError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class VocabulariesLoaded implements VocabulariesState {
  const factory VocabulariesLoaded(final List<Vocabulary> vocabularies) =
      _$VocabulariesLoadedImpl;

  List<Vocabulary> get vocabularies;

  /// Create a copy of VocabulariesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VocabulariesLoadedImplCopyWith<_$VocabulariesLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$VocabulariesErrorImplCopyWith<$Res> {
  factory _$$VocabulariesErrorImplCopyWith(_$VocabulariesErrorImpl value,
          $Res Function(_$VocabulariesErrorImpl) then) =
      __$$VocabulariesErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$VocabulariesErrorImplCopyWithImpl<$Res>
    extends _$VocabulariesStateCopyWithImpl<$Res, _$VocabulariesErrorImpl>
    implements _$$VocabulariesErrorImplCopyWith<$Res> {
  __$$VocabulariesErrorImplCopyWithImpl(_$VocabulariesErrorImpl _value,
      $Res Function(_$VocabulariesErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of VocabulariesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$VocabulariesErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$VocabulariesErrorImpl implements VocabulariesError {
  const _$VocabulariesErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'VocabulariesState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VocabulariesErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of VocabulariesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VocabulariesErrorImplCopyWith<_$VocabulariesErrorImpl> get copyWith =>
      __$$VocabulariesErrorImplCopyWithImpl<_$VocabulariesErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Vocabulary> vocabularies) loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Vocabulary> vocabularies)? loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Vocabulary> vocabularies)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VocabulariesInitial value) initial,
    required TResult Function(VocabulariesLoading value) loading,
    required TResult Function(VocabulariesLoaded value) loaded,
    required TResult Function(VocabulariesError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VocabulariesInitial value)? initial,
    TResult? Function(VocabulariesLoading value)? loading,
    TResult? Function(VocabulariesLoaded value)? loaded,
    TResult? Function(VocabulariesError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VocabulariesInitial value)? initial,
    TResult Function(VocabulariesLoading value)? loading,
    TResult Function(VocabulariesLoaded value)? loaded,
    TResult Function(VocabulariesError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class VocabulariesError implements VocabulariesState {
  const factory VocabulariesError(final String message) =
      _$VocabulariesErrorImpl;

  String get message;

  /// Create a copy of VocabulariesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VocabulariesErrorImplCopyWith<_$VocabulariesErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PhrasesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Phrase> phrases) loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Phrase> phrases)? loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Phrase> phrases)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PhrasesInitial value) initial,
    required TResult Function(PhrasesLoading value) loading,
    required TResult Function(PhrasesLoaded value) loaded,
    required TResult Function(PhrasesError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PhrasesInitial value)? initial,
    TResult? Function(PhrasesLoading value)? loading,
    TResult? Function(PhrasesLoaded value)? loaded,
    TResult? Function(PhrasesError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PhrasesInitial value)? initial,
    TResult Function(PhrasesLoading value)? loading,
    TResult Function(PhrasesLoaded value)? loaded,
    TResult Function(PhrasesError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PhrasesStateCopyWith<$Res> {
  factory $PhrasesStateCopyWith(
          PhrasesState value, $Res Function(PhrasesState) then) =
      _$PhrasesStateCopyWithImpl<$Res, PhrasesState>;
}

/// @nodoc
class _$PhrasesStateCopyWithImpl<$Res, $Val extends PhrasesState>
    implements $PhrasesStateCopyWith<$Res> {
  _$PhrasesStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PhrasesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$PhrasesInitialImplCopyWith<$Res> {
  factory _$$PhrasesInitialImplCopyWith(_$PhrasesInitialImpl value,
          $Res Function(_$PhrasesInitialImpl) then) =
      __$$PhrasesInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PhrasesInitialImplCopyWithImpl<$Res>
    extends _$PhrasesStateCopyWithImpl<$Res, _$PhrasesInitialImpl>
    implements _$$PhrasesInitialImplCopyWith<$Res> {
  __$$PhrasesInitialImplCopyWithImpl(
      _$PhrasesInitialImpl _value, $Res Function(_$PhrasesInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of PhrasesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PhrasesInitialImpl implements PhrasesInitial {
  const _$PhrasesInitialImpl();

  @override
  String toString() {
    return 'PhrasesState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PhrasesInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Phrase> phrases) loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Phrase> phrases)? loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Phrase> phrases)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PhrasesInitial value) initial,
    required TResult Function(PhrasesLoading value) loading,
    required TResult Function(PhrasesLoaded value) loaded,
    required TResult Function(PhrasesError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PhrasesInitial value)? initial,
    TResult? Function(PhrasesLoading value)? loading,
    TResult? Function(PhrasesLoaded value)? loaded,
    TResult? Function(PhrasesError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PhrasesInitial value)? initial,
    TResult Function(PhrasesLoading value)? loading,
    TResult Function(PhrasesLoaded value)? loaded,
    TResult Function(PhrasesError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class PhrasesInitial implements PhrasesState {
  const factory PhrasesInitial() = _$PhrasesInitialImpl;
}

/// @nodoc
abstract class _$$PhrasesLoadingImplCopyWith<$Res> {
  factory _$$PhrasesLoadingImplCopyWith(_$PhrasesLoadingImpl value,
          $Res Function(_$PhrasesLoadingImpl) then) =
      __$$PhrasesLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PhrasesLoadingImplCopyWithImpl<$Res>
    extends _$PhrasesStateCopyWithImpl<$Res, _$PhrasesLoadingImpl>
    implements _$$PhrasesLoadingImplCopyWith<$Res> {
  __$$PhrasesLoadingImplCopyWithImpl(
      _$PhrasesLoadingImpl _value, $Res Function(_$PhrasesLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of PhrasesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PhrasesLoadingImpl implements PhrasesLoading {
  const _$PhrasesLoadingImpl();

  @override
  String toString() {
    return 'PhrasesState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PhrasesLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Phrase> phrases) loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Phrase> phrases)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Phrase> phrases)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PhrasesInitial value) initial,
    required TResult Function(PhrasesLoading value) loading,
    required TResult Function(PhrasesLoaded value) loaded,
    required TResult Function(PhrasesError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PhrasesInitial value)? initial,
    TResult? Function(PhrasesLoading value)? loading,
    TResult? Function(PhrasesLoaded value)? loaded,
    TResult? Function(PhrasesError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PhrasesInitial value)? initial,
    TResult Function(PhrasesLoading value)? loading,
    TResult Function(PhrasesLoaded value)? loaded,
    TResult Function(PhrasesError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class PhrasesLoading implements PhrasesState {
  const factory PhrasesLoading() = _$PhrasesLoadingImpl;
}

/// @nodoc
abstract class _$$PhrasesLoadedImplCopyWith<$Res> {
  factory _$$PhrasesLoadedImplCopyWith(
          _$PhrasesLoadedImpl value, $Res Function(_$PhrasesLoadedImpl) then) =
      __$$PhrasesLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Phrase> phrases});
}

/// @nodoc
class __$$PhrasesLoadedImplCopyWithImpl<$Res>
    extends _$PhrasesStateCopyWithImpl<$Res, _$PhrasesLoadedImpl>
    implements _$$PhrasesLoadedImplCopyWith<$Res> {
  __$$PhrasesLoadedImplCopyWithImpl(
      _$PhrasesLoadedImpl _value, $Res Function(_$PhrasesLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of PhrasesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? phrases = null,
  }) {
    return _then(_$PhrasesLoadedImpl(
      null == phrases
          ? _value._phrases
          : phrases // ignore: cast_nullable_to_non_nullable
              as List<Phrase>,
    ));
  }
}

/// @nodoc

class _$PhrasesLoadedImpl implements PhrasesLoaded {
  const _$PhrasesLoadedImpl(final List<Phrase> phrases) : _phrases = phrases;

  final List<Phrase> _phrases;
  @override
  List<Phrase> get phrases {
    if (_phrases is EqualUnmodifiableListView) return _phrases;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_phrases);
  }

  @override
  String toString() {
    return 'PhrasesState.loaded(phrases: $phrases)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PhrasesLoadedImpl &&
            const DeepCollectionEquality().equals(other._phrases, _phrases));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_phrases));

  /// Create a copy of PhrasesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PhrasesLoadedImplCopyWith<_$PhrasesLoadedImpl> get copyWith =>
      __$$PhrasesLoadedImplCopyWithImpl<_$PhrasesLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Phrase> phrases) loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(phrases);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Phrase> phrases)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(phrases);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Phrase> phrases)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(phrases);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PhrasesInitial value) initial,
    required TResult Function(PhrasesLoading value) loading,
    required TResult Function(PhrasesLoaded value) loaded,
    required TResult Function(PhrasesError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PhrasesInitial value)? initial,
    TResult? Function(PhrasesLoading value)? loading,
    TResult? Function(PhrasesLoaded value)? loaded,
    TResult? Function(PhrasesError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PhrasesInitial value)? initial,
    TResult Function(PhrasesLoading value)? loading,
    TResult Function(PhrasesLoaded value)? loaded,
    TResult Function(PhrasesError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class PhrasesLoaded implements PhrasesState {
  const factory PhrasesLoaded(final List<Phrase> phrases) = _$PhrasesLoadedImpl;

  List<Phrase> get phrases;

  /// Create a copy of PhrasesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PhrasesLoadedImplCopyWith<_$PhrasesLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PhrasesErrorImplCopyWith<$Res> {
  factory _$$PhrasesErrorImplCopyWith(
          _$PhrasesErrorImpl value, $Res Function(_$PhrasesErrorImpl) then) =
      __$$PhrasesErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$PhrasesErrorImplCopyWithImpl<$Res>
    extends _$PhrasesStateCopyWithImpl<$Res, _$PhrasesErrorImpl>
    implements _$$PhrasesErrorImplCopyWith<$Res> {
  __$$PhrasesErrorImplCopyWithImpl(
      _$PhrasesErrorImpl _value, $Res Function(_$PhrasesErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of PhrasesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$PhrasesErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PhrasesErrorImpl implements PhrasesError {
  const _$PhrasesErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'PhrasesState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PhrasesErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of PhrasesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PhrasesErrorImplCopyWith<_$PhrasesErrorImpl> get copyWith =>
      __$$PhrasesErrorImplCopyWithImpl<_$PhrasesErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Phrase> phrases) loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Phrase> phrases)? loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Phrase> phrases)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PhrasesInitial value) initial,
    required TResult Function(PhrasesLoading value) loading,
    required TResult Function(PhrasesLoaded value) loaded,
    required TResult Function(PhrasesError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PhrasesInitial value)? initial,
    TResult? Function(PhrasesLoading value)? loading,
    TResult? Function(PhrasesLoaded value)? loaded,
    TResult? Function(PhrasesError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PhrasesInitial value)? initial,
    TResult Function(PhrasesLoading value)? loading,
    TResult Function(PhrasesLoaded value)? loaded,
    TResult Function(PhrasesError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PhrasesError implements PhrasesState {
  const factory PhrasesError(final String message) = _$PhrasesErrorImpl;

  String get message;

  /// Create a copy of PhrasesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PhrasesErrorImplCopyWith<_$PhrasesErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UserAnalyticsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(Map<String, dynamic> analytics) loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(Map<String, dynamic> analytics)? loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(Map<String, dynamic> analytics)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserAnalyticsInitial value) initial,
    required TResult Function(UserAnalyticsLoading value) loading,
    required TResult Function(UserAnalyticsLoaded value) loaded,
    required TResult Function(UserAnalyticsError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserAnalyticsInitial value)? initial,
    TResult? Function(UserAnalyticsLoading value)? loading,
    TResult? Function(UserAnalyticsLoaded value)? loaded,
    TResult? Function(UserAnalyticsError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserAnalyticsInitial value)? initial,
    TResult Function(UserAnalyticsLoading value)? loading,
    TResult Function(UserAnalyticsLoaded value)? loaded,
    TResult Function(UserAnalyticsError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserAnalyticsStateCopyWith<$Res> {
  factory $UserAnalyticsStateCopyWith(
          UserAnalyticsState value, $Res Function(UserAnalyticsState) then) =
      _$UserAnalyticsStateCopyWithImpl<$Res, UserAnalyticsState>;
}

/// @nodoc
class _$UserAnalyticsStateCopyWithImpl<$Res, $Val extends UserAnalyticsState>
    implements $UserAnalyticsStateCopyWith<$Res> {
  _$UserAnalyticsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UserAnalyticsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$UserAnalyticsInitialImplCopyWith<$Res> {
  factory _$$UserAnalyticsInitialImplCopyWith(_$UserAnalyticsInitialImpl value,
          $Res Function(_$UserAnalyticsInitialImpl) then) =
      __$$UserAnalyticsInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserAnalyticsInitialImplCopyWithImpl<$Res>
    extends _$UserAnalyticsStateCopyWithImpl<$Res, _$UserAnalyticsInitialImpl>
    implements _$$UserAnalyticsInitialImplCopyWith<$Res> {
  __$$UserAnalyticsInitialImplCopyWithImpl(_$UserAnalyticsInitialImpl _value,
      $Res Function(_$UserAnalyticsInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserAnalyticsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UserAnalyticsInitialImpl implements UserAnalyticsInitial {
  const _$UserAnalyticsInitialImpl();

  @override
  String toString() {
    return 'UserAnalyticsState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserAnalyticsInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(Map<String, dynamic> analytics) loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(Map<String, dynamic> analytics)? loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(Map<String, dynamic> analytics)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserAnalyticsInitial value) initial,
    required TResult Function(UserAnalyticsLoading value) loading,
    required TResult Function(UserAnalyticsLoaded value) loaded,
    required TResult Function(UserAnalyticsError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserAnalyticsInitial value)? initial,
    TResult? Function(UserAnalyticsLoading value)? loading,
    TResult? Function(UserAnalyticsLoaded value)? loaded,
    TResult? Function(UserAnalyticsError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserAnalyticsInitial value)? initial,
    TResult Function(UserAnalyticsLoading value)? loading,
    TResult Function(UserAnalyticsLoaded value)? loaded,
    TResult Function(UserAnalyticsError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class UserAnalyticsInitial implements UserAnalyticsState {
  const factory UserAnalyticsInitial() = _$UserAnalyticsInitialImpl;
}

/// @nodoc
abstract class _$$UserAnalyticsLoadingImplCopyWith<$Res> {
  factory _$$UserAnalyticsLoadingImplCopyWith(_$UserAnalyticsLoadingImpl value,
          $Res Function(_$UserAnalyticsLoadingImpl) then) =
      __$$UserAnalyticsLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserAnalyticsLoadingImplCopyWithImpl<$Res>
    extends _$UserAnalyticsStateCopyWithImpl<$Res, _$UserAnalyticsLoadingImpl>
    implements _$$UserAnalyticsLoadingImplCopyWith<$Res> {
  __$$UserAnalyticsLoadingImplCopyWithImpl(_$UserAnalyticsLoadingImpl _value,
      $Res Function(_$UserAnalyticsLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserAnalyticsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UserAnalyticsLoadingImpl implements UserAnalyticsLoading {
  const _$UserAnalyticsLoadingImpl();

  @override
  String toString() {
    return 'UserAnalyticsState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserAnalyticsLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(Map<String, dynamic> analytics) loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(Map<String, dynamic> analytics)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(Map<String, dynamic> analytics)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserAnalyticsInitial value) initial,
    required TResult Function(UserAnalyticsLoading value) loading,
    required TResult Function(UserAnalyticsLoaded value) loaded,
    required TResult Function(UserAnalyticsError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserAnalyticsInitial value)? initial,
    TResult? Function(UserAnalyticsLoading value)? loading,
    TResult? Function(UserAnalyticsLoaded value)? loaded,
    TResult? Function(UserAnalyticsError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserAnalyticsInitial value)? initial,
    TResult Function(UserAnalyticsLoading value)? loading,
    TResult Function(UserAnalyticsLoaded value)? loaded,
    TResult Function(UserAnalyticsError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class UserAnalyticsLoading implements UserAnalyticsState {
  const factory UserAnalyticsLoading() = _$UserAnalyticsLoadingImpl;
}

/// @nodoc
abstract class _$$UserAnalyticsLoadedImplCopyWith<$Res> {
  factory _$$UserAnalyticsLoadedImplCopyWith(_$UserAnalyticsLoadedImpl value,
          $Res Function(_$UserAnalyticsLoadedImpl) then) =
      __$$UserAnalyticsLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Map<String, dynamic> analytics});
}

/// @nodoc
class __$$UserAnalyticsLoadedImplCopyWithImpl<$Res>
    extends _$UserAnalyticsStateCopyWithImpl<$Res, _$UserAnalyticsLoadedImpl>
    implements _$$UserAnalyticsLoadedImplCopyWith<$Res> {
  __$$UserAnalyticsLoadedImplCopyWithImpl(_$UserAnalyticsLoadedImpl _value,
      $Res Function(_$UserAnalyticsLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserAnalyticsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? analytics = null,
  }) {
    return _then(_$UserAnalyticsLoadedImpl(
      null == analytics
          ? _value._analytics
          : analytics // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc

class _$UserAnalyticsLoadedImpl implements UserAnalyticsLoaded {
  const _$UserAnalyticsLoadedImpl(final Map<String, dynamic> analytics)
      : _analytics = analytics;

  final Map<String, dynamic> _analytics;
  @override
  Map<String, dynamic> get analytics {
    if (_analytics is EqualUnmodifiableMapView) return _analytics;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_analytics);
  }

  @override
  String toString() {
    return 'UserAnalyticsState.loaded(analytics: $analytics)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserAnalyticsLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._analytics, _analytics));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_analytics));

  /// Create a copy of UserAnalyticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserAnalyticsLoadedImplCopyWith<_$UserAnalyticsLoadedImpl> get copyWith =>
      __$$UserAnalyticsLoadedImplCopyWithImpl<_$UserAnalyticsLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(Map<String, dynamic> analytics) loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(analytics);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(Map<String, dynamic> analytics)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(analytics);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(Map<String, dynamic> analytics)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(analytics);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserAnalyticsInitial value) initial,
    required TResult Function(UserAnalyticsLoading value) loading,
    required TResult Function(UserAnalyticsLoaded value) loaded,
    required TResult Function(UserAnalyticsError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserAnalyticsInitial value)? initial,
    TResult? Function(UserAnalyticsLoading value)? loading,
    TResult? Function(UserAnalyticsLoaded value)? loaded,
    TResult? Function(UserAnalyticsError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserAnalyticsInitial value)? initial,
    TResult Function(UserAnalyticsLoading value)? loading,
    TResult Function(UserAnalyticsLoaded value)? loaded,
    TResult Function(UserAnalyticsError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class UserAnalyticsLoaded implements UserAnalyticsState {
  const factory UserAnalyticsLoaded(final Map<String, dynamic> analytics) =
      _$UserAnalyticsLoadedImpl;

  Map<String, dynamic> get analytics;

  /// Create a copy of UserAnalyticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserAnalyticsLoadedImplCopyWith<_$UserAnalyticsLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserAnalyticsErrorImplCopyWith<$Res> {
  factory _$$UserAnalyticsErrorImplCopyWith(_$UserAnalyticsErrorImpl value,
          $Res Function(_$UserAnalyticsErrorImpl) then) =
      __$$UserAnalyticsErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$UserAnalyticsErrorImplCopyWithImpl<$Res>
    extends _$UserAnalyticsStateCopyWithImpl<$Res, _$UserAnalyticsErrorImpl>
    implements _$$UserAnalyticsErrorImplCopyWith<$Res> {
  __$$UserAnalyticsErrorImplCopyWithImpl(_$UserAnalyticsErrorImpl _value,
      $Res Function(_$UserAnalyticsErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserAnalyticsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$UserAnalyticsErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UserAnalyticsErrorImpl implements UserAnalyticsError {
  const _$UserAnalyticsErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'UserAnalyticsState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserAnalyticsErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of UserAnalyticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserAnalyticsErrorImplCopyWith<_$UserAnalyticsErrorImpl> get copyWith =>
      __$$UserAnalyticsErrorImplCopyWithImpl<_$UserAnalyticsErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(Map<String, dynamic> analytics) loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(Map<String, dynamic> analytics)? loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(Map<String, dynamic> analytics)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserAnalyticsInitial value) initial,
    required TResult Function(UserAnalyticsLoading value) loading,
    required TResult Function(UserAnalyticsLoaded value) loaded,
    required TResult Function(UserAnalyticsError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserAnalyticsInitial value)? initial,
    TResult? Function(UserAnalyticsLoading value)? loading,
    TResult? Function(UserAnalyticsLoaded value)? loaded,
    TResult? Function(UserAnalyticsError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserAnalyticsInitial value)? initial,
    TResult Function(UserAnalyticsLoading value)? loading,
    TResult Function(UserAnalyticsLoaded value)? loaded,
    TResult Function(UserAnalyticsError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class UserAnalyticsError implements UserAnalyticsState {
  const factory UserAnalyticsError(final String message) =
      _$UserAnalyticsErrorImpl;

  String get message;

  /// Create a copy of UserAnalyticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserAnalyticsErrorImplCopyWith<_$UserAnalyticsErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UserDataManagementState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDataManagementInitial value) initial,
    required TResult Function(UserDataManagementLoading value) loading,
    required TResult Function(UserDataManagementSuccess value) success,
    required TResult Function(UserDataManagementError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDataManagementInitial value)? initial,
    TResult? Function(UserDataManagementLoading value)? loading,
    TResult? Function(UserDataManagementSuccess value)? success,
    TResult? Function(UserDataManagementError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDataManagementInitial value)? initial,
    TResult Function(UserDataManagementLoading value)? loading,
    TResult Function(UserDataManagementSuccess value)? success,
    TResult Function(UserDataManagementError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserDataManagementStateCopyWith<$Res> {
  factory $UserDataManagementStateCopyWith(UserDataManagementState value,
          $Res Function(UserDataManagementState) then) =
      _$UserDataManagementStateCopyWithImpl<$Res, UserDataManagementState>;
}

/// @nodoc
class _$UserDataManagementStateCopyWithImpl<$Res,
        $Val extends UserDataManagementState>
    implements $UserDataManagementStateCopyWith<$Res> {
  _$UserDataManagementStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UserDataManagementState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$UserDataManagementInitialImplCopyWith<$Res> {
  factory _$$UserDataManagementInitialImplCopyWith(
          _$UserDataManagementInitialImpl value,
          $Res Function(_$UserDataManagementInitialImpl) then) =
      __$$UserDataManagementInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserDataManagementInitialImplCopyWithImpl<$Res>
    extends _$UserDataManagementStateCopyWithImpl<$Res,
        _$UserDataManagementInitialImpl>
    implements _$$UserDataManagementInitialImplCopyWith<$Res> {
  __$$UserDataManagementInitialImplCopyWithImpl(
      _$UserDataManagementInitialImpl _value,
      $Res Function(_$UserDataManagementInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserDataManagementState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UserDataManagementInitialImpl implements UserDataManagementInitial {
  const _$UserDataManagementInitialImpl();

  @override
  String toString() {
    return 'UserDataManagementState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserDataManagementInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDataManagementInitial value) initial,
    required TResult Function(UserDataManagementLoading value) loading,
    required TResult Function(UserDataManagementSuccess value) success,
    required TResult Function(UserDataManagementError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDataManagementInitial value)? initial,
    TResult? Function(UserDataManagementLoading value)? loading,
    TResult? Function(UserDataManagementSuccess value)? success,
    TResult? Function(UserDataManagementError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDataManagementInitial value)? initial,
    TResult Function(UserDataManagementLoading value)? loading,
    TResult Function(UserDataManagementSuccess value)? success,
    TResult Function(UserDataManagementError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class UserDataManagementInitial implements UserDataManagementState {
  const factory UserDataManagementInitial() = _$UserDataManagementInitialImpl;
}

/// @nodoc
abstract class _$$UserDataManagementLoadingImplCopyWith<$Res> {
  factory _$$UserDataManagementLoadingImplCopyWith(
          _$UserDataManagementLoadingImpl value,
          $Res Function(_$UserDataManagementLoadingImpl) then) =
      __$$UserDataManagementLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserDataManagementLoadingImplCopyWithImpl<$Res>
    extends _$UserDataManagementStateCopyWithImpl<$Res,
        _$UserDataManagementLoadingImpl>
    implements _$$UserDataManagementLoadingImplCopyWith<$Res> {
  __$$UserDataManagementLoadingImplCopyWithImpl(
      _$UserDataManagementLoadingImpl _value,
      $Res Function(_$UserDataManagementLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserDataManagementState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UserDataManagementLoadingImpl implements UserDataManagementLoading {
  const _$UserDataManagementLoadingImpl();

  @override
  String toString() {
    return 'UserDataManagementState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserDataManagementLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDataManagementInitial value) initial,
    required TResult Function(UserDataManagementLoading value) loading,
    required TResult Function(UserDataManagementSuccess value) success,
    required TResult Function(UserDataManagementError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDataManagementInitial value)? initial,
    TResult? Function(UserDataManagementLoading value)? loading,
    TResult? Function(UserDataManagementSuccess value)? success,
    TResult? Function(UserDataManagementError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDataManagementInitial value)? initial,
    TResult Function(UserDataManagementLoading value)? loading,
    TResult Function(UserDataManagementSuccess value)? success,
    TResult Function(UserDataManagementError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class UserDataManagementLoading implements UserDataManagementState {
  const factory UserDataManagementLoading() = _$UserDataManagementLoadingImpl;
}

/// @nodoc
abstract class _$$UserDataManagementSuccessImplCopyWith<$Res> {
  factory _$$UserDataManagementSuccessImplCopyWith(
          _$UserDataManagementSuccessImpl value,
          $Res Function(_$UserDataManagementSuccessImpl) then) =
      __$$UserDataManagementSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserDataManagementSuccessImplCopyWithImpl<$Res>
    extends _$UserDataManagementStateCopyWithImpl<$Res,
        _$UserDataManagementSuccessImpl>
    implements _$$UserDataManagementSuccessImplCopyWith<$Res> {
  __$$UserDataManagementSuccessImplCopyWithImpl(
      _$UserDataManagementSuccessImpl _value,
      $Res Function(_$UserDataManagementSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserDataManagementState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UserDataManagementSuccessImpl implements UserDataManagementSuccess {
  const _$UserDataManagementSuccessImpl();

  @override
  String toString() {
    return 'UserDataManagementState.success()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserDataManagementSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String message) error,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String message)? error,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDataManagementInitial value) initial,
    required TResult Function(UserDataManagementLoading value) loading,
    required TResult Function(UserDataManagementSuccess value) success,
    required TResult Function(UserDataManagementError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDataManagementInitial value)? initial,
    TResult? Function(UserDataManagementLoading value)? loading,
    TResult? Function(UserDataManagementSuccess value)? success,
    TResult? Function(UserDataManagementError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDataManagementInitial value)? initial,
    TResult Function(UserDataManagementLoading value)? loading,
    TResult Function(UserDataManagementSuccess value)? success,
    TResult Function(UserDataManagementError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class UserDataManagementSuccess implements UserDataManagementState {
  const factory UserDataManagementSuccess() = _$UserDataManagementSuccessImpl;
}

/// @nodoc
abstract class _$$UserDataManagementErrorImplCopyWith<$Res> {
  factory _$$UserDataManagementErrorImplCopyWith(
          _$UserDataManagementErrorImpl value,
          $Res Function(_$UserDataManagementErrorImpl) then) =
      __$$UserDataManagementErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$UserDataManagementErrorImplCopyWithImpl<$Res>
    extends _$UserDataManagementStateCopyWithImpl<$Res,
        _$UserDataManagementErrorImpl>
    implements _$$UserDataManagementErrorImplCopyWith<$Res> {
  __$$UserDataManagementErrorImplCopyWithImpl(
      _$UserDataManagementErrorImpl _value,
      $Res Function(_$UserDataManagementErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserDataManagementState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$UserDataManagementErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UserDataManagementErrorImpl implements UserDataManagementError {
  const _$UserDataManagementErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'UserDataManagementState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserDataManagementErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of UserDataManagementState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserDataManagementErrorImplCopyWith<_$UserDataManagementErrorImpl>
      get copyWith => __$$UserDataManagementErrorImplCopyWithImpl<
          _$UserDataManagementErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDataManagementInitial value) initial,
    required TResult Function(UserDataManagementLoading value) loading,
    required TResult Function(UserDataManagementSuccess value) success,
    required TResult Function(UserDataManagementError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDataManagementInitial value)? initial,
    TResult? Function(UserDataManagementLoading value)? loading,
    TResult? Function(UserDataManagementSuccess value)? success,
    TResult? Function(UserDataManagementError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDataManagementInitial value)? initial,
    TResult Function(UserDataManagementLoading value)? loading,
    TResult Function(UserDataManagementSuccess value)? success,
    TResult Function(UserDataManagementError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class UserDataManagementError implements UserDataManagementState {
  const factory UserDataManagementError(final String message) =
      _$UserDataManagementErrorImpl;

  String get message;

  /// Create a copy of UserDataManagementState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserDataManagementErrorImplCopyWith<_$UserDataManagementErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ConversationState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)
        loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)?
        loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConversationInitial value) initial,
    required TResult Function(ConversationLoading value) loading,
    required TResult Function(ConversationLoaded value) loaded,
    required TResult Function(ConversationError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConversationInitial value)? initial,
    TResult? Function(ConversationLoading value)? loading,
    TResult? Function(ConversationLoaded value)? loaded,
    TResult? Function(ConversationError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConversationInitial value)? initial,
    TResult Function(ConversationLoading value)? loading,
    TResult Function(ConversationLoaded value)? loaded,
    TResult Function(ConversationError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConversationStateCopyWith<$Res> {
  factory $ConversationStateCopyWith(
          ConversationState value, $Res Function(ConversationState) then) =
      _$ConversationStateCopyWithImpl<$Res, ConversationState>;
}

/// @nodoc
class _$ConversationStateCopyWithImpl<$Res, $Val extends ConversationState>
    implements $ConversationStateCopyWith<$Res> {
  _$ConversationStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ConversationState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ConversationInitialImplCopyWith<$Res> {
  factory _$$ConversationInitialImplCopyWith(_$ConversationInitialImpl value,
          $Res Function(_$ConversationInitialImpl) then) =
      __$$ConversationInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConversationInitialImplCopyWithImpl<$Res>
    extends _$ConversationStateCopyWithImpl<$Res, _$ConversationInitialImpl>
    implements _$$ConversationInitialImplCopyWith<$Res> {
  __$$ConversationInitialImplCopyWithImpl(_$ConversationInitialImpl _value,
      $Res Function(_$ConversationInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of ConversationState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ConversationInitialImpl implements ConversationInitial {
  const _$ConversationInitialImpl();

  @override
  String toString() {
    return 'ConversationState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConversationInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)
        loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConversationInitial value) initial,
    required TResult Function(ConversationLoading value) loading,
    required TResult Function(ConversationLoaded value) loaded,
    required TResult Function(ConversationError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConversationInitial value)? initial,
    TResult? Function(ConversationLoading value)? loading,
    TResult? Function(ConversationLoaded value)? loaded,
    TResult? Function(ConversationError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConversationInitial value)? initial,
    TResult Function(ConversationLoading value)? loading,
    TResult Function(ConversationLoaded value)? loaded,
    TResult Function(ConversationError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class ConversationInitial implements ConversationState {
  const factory ConversationInitial() = _$ConversationInitialImpl;
}

/// @nodoc
abstract class _$$ConversationLoadingImplCopyWith<$Res> {
  factory _$$ConversationLoadingImplCopyWith(_$ConversationLoadingImpl value,
          $Res Function(_$ConversationLoadingImpl) then) =
      __$$ConversationLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConversationLoadingImplCopyWithImpl<$Res>
    extends _$ConversationStateCopyWithImpl<$Res, _$ConversationLoadingImpl>
    implements _$$ConversationLoadingImplCopyWith<$Res> {
  __$$ConversationLoadingImplCopyWithImpl(_$ConversationLoadingImpl _value,
      $Res Function(_$ConversationLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of ConversationState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ConversationLoadingImpl implements ConversationLoading {
  const _$ConversationLoadingImpl();

  @override
  String toString() {
    return 'ConversationState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConversationLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)
        loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConversationInitial value) initial,
    required TResult Function(ConversationLoading value) loading,
    required TResult Function(ConversationLoaded value) loaded,
    required TResult Function(ConversationError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConversationInitial value)? initial,
    TResult? Function(ConversationLoading value)? loading,
    TResult? Function(ConversationLoaded value)? loaded,
    TResult? Function(ConversationError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConversationInitial value)? initial,
    TResult Function(ConversationLoading value)? loading,
    TResult Function(ConversationLoaded value)? loaded,
    TResult Function(ConversationError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class ConversationLoading implements ConversationState {
  const factory ConversationLoading() = _$ConversationLoadingImpl;
}

/// @nodoc
abstract class _$$ConversationLoadedImplCopyWith<$Res> {
  factory _$$ConversationLoadedImplCopyWith(_$ConversationLoadedImpl value,
          $Res Function(_$ConversationLoadedImpl) then) =
      __$$ConversationLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {ConversationThreadModel? currentThread,
      List<ConversationMessageModel> messages,
      List<ConversationThreadModel> userThreads});
}

/// @nodoc
class __$$ConversationLoadedImplCopyWithImpl<$Res>
    extends _$ConversationStateCopyWithImpl<$Res, _$ConversationLoadedImpl>
    implements _$$ConversationLoadedImplCopyWith<$Res> {
  __$$ConversationLoadedImplCopyWithImpl(_$ConversationLoadedImpl _value,
      $Res Function(_$ConversationLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of ConversationState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentThread = freezed,
    Object? messages = null,
    Object? userThreads = null,
  }) {
    return _then(_$ConversationLoadedImpl(
      currentThread: freezed == currentThread
          ? _value.currentThread
          : currentThread // ignore: cast_nullable_to_non_nullable
              as ConversationThreadModel?,
      messages: null == messages
          ? _value._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ConversationMessageModel>,
      userThreads: null == userThreads
          ? _value._userThreads
          : userThreads // ignore: cast_nullable_to_non_nullable
              as List<ConversationThreadModel>,
    ));
  }
}

/// @nodoc

class _$ConversationLoadedImpl implements ConversationLoaded {
  const _$ConversationLoadedImpl(
      {required this.currentThread,
      required final List<ConversationMessageModel> messages,
      required final List<ConversationThreadModel> userThreads})
      : _messages = messages,
        _userThreads = userThreads;

  @override
  final ConversationThreadModel? currentThread;
  final List<ConversationMessageModel> _messages;
  @override
  List<ConversationMessageModel> get messages {
    if (_messages is EqualUnmodifiableListView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_messages);
  }

  final List<ConversationThreadModel> _userThreads;
  @override
  List<ConversationThreadModel> get userThreads {
    if (_userThreads is EqualUnmodifiableListView) return _userThreads;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userThreads);
  }

  @override
  String toString() {
    return 'ConversationState.loaded(currentThread: $currentThread, messages: $messages, userThreads: $userThreads)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConversationLoadedImpl &&
            (identical(other.currentThread, currentThread) ||
                other.currentThread == currentThread) &&
            const DeepCollectionEquality().equals(other._messages, _messages) &&
            const DeepCollectionEquality()
                .equals(other._userThreads, _userThreads));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      currentThread,
      const DeepCollectionEquality().hash(_messages),
      const DeepCollectionEquality().hash(_userThreads));

  /// Create a copy of ConversationState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConversationLoadedImplCopyWith<_$ConversationLoadedImpl> get copyWith =>
      __$$ConversationLoadedImplCopyWithImpl<_$ConversationLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)
        loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(currentThread, messages, userThreads);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(currentThread, messages, userThreads);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(currentThread, messages, userThreads);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConversationInitial value) initial,
    required TResult Function(ConversationLoading value) loading,
    required TResult Function(ConversationLoaded value) loaded,
    required TResult Function(ConversationError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConversationInitial value)? initial,
    TResult? Function(ConversationLoading value)? loading,
    TResult? Function(ConversationLoaded value)? loaded,
    TResult? Function(ConversationError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConversationInitial value)? initial,
    TResult Function(ConversationLoading value)? loading,
    TResult Function(ConversationLoaded value)? loaded,
    TResult Function(ConversationError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class ConversationLoaded implements ConversationState {
  const factory ConversationLoaded(
          {required final ConversationThreadModel? currentThread,
          required final List<ConversationMessageModel> messages,
          required final List<ConversationThreadModel> userThreads}) =
      _$ConversationLoadedImpl;

  ConversationThreadModel? get currentThread;
  List<ConversationMessageModel> get messages;
  List<ConversationThreadModel> get userThreads;

  /// Create a copy of ConversationState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConversationLoadedImplCopyWith<_$ConversationLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConversationErrorImplCopyWith<$Res> {
  factory _$$ConversationErrorImplCopyWith(_$ConversationErrorImpl value,
          $Res Function(_$ConversationErrorImpl) then) =
      __$$ConversationErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ConversationErrorImplCopyWithImpl<$Res>
    extends _$ConversationStateCopyWithImpl<$Res, _$ConversationErrorImpl>
    implements _$$ConversationErrorImplCopyWith<$Res> {
  __$$ConversationErrorImplCopyWithImpl(_$ConversationErrorImpl _value,
      $Res Function(_$ConversationErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of ConversationState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ConversationErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ConversationErrorImpl implements ConversationError {
  const _$ConversationErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'ConversationState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConversationErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of ConversationState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConversationErrorImplCopyWith<_$ConversationErrorImpl> get copyWith =>
      __$$ConversationErrorImplCopyWithImpl<_$ConversationErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)
        loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            ConversationThreadModel? currentThread,
            List<ConversationMessageModel> messages,
            List<ConversationThreadModel> userThreads)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConversationInitial value) initial,
    required TResult Function(ConversationLoading value) loading,
    required TResult Function(ConversationLoaded value) loaded,
    required TResult Function(ConversationError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConversationInitial value)? initial,
    TResult? Function(ConversationLoading value)? loading,
    TResult? Function(ConversationLoaded value)? loaded,
    TResult? Function(ConversationError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConversationInitial value)? initial,
    TResult Function(ConversationLoading value)? loading,
    TResult Function(ConversationLoaded value)? loaded,
    TResult Function(ConversationError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ConversationError implements ConversationState {
  const factory ConversationError(final String message) =
      _$ConversationErrorImpl;

  String get message;

  /// Create a copy of ConversationState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConversationErrorImplCopyWith<_$ConversationErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DailyLessonsState {
  VocabulariesState get vocabularies => throw _privateConstructorUsedError;
  PhrasesState get phrases => throw _privateConstructorUsedError;
  UserAnalyticsState get analytics => throw _privateConstructorUsedError;
  UserDataManagementState get dataManagement =>
      throw _privateConstructorUsedError;
  ConversationState get conversation => throw _privateConstructorUsedError;
  bool get isRefreshing => throw _privateConstructorUsedError;

  /// Create a copy of DailyLessonsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DailyLessonsStateCopyWith<DailyLessonsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DailyLessonsStateCopyWith<$Res> {
  factory $DailyLessonsStateCopyWith(
          DailyLessonsState value, $Res Function(DailyLessonsState) then) =
      _$DailyLessonsStateCopyWithImpl<$Res, DailyLessonsState>;
  @useResult
  $Res call(
      {VocabulariesState vocabularies,
      PhrasesState phrases,
      UserAnalyticsState analytics,
      UserDataManagementState dataManagement,
      ConversationState conversation,
      bool isRefreshing});

  $VocabulariesStateCopyWith<$Res> get vocabularies;
  $PhrasesStateCopyWith<$Res> get phrases;
  $UserAnalyticsStateCopyWith<$Res> get analytics;
  $UserDataManagementStateCopyWith<$Res> get dataManagement;
  $ConversationStateCopyWith<$Res> get conversation;
}

/// @nodoc
class _$DailyLessonsStateCopyWithImpl<$Res, $Val extends DailyLessonsState>
    implements $DailyLessonsStateCopyWith<$Res> {
  _$DailyLessonsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DailyLessonsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vocabularies = null,
    Object? phrases = null,
    Object? analytics = null,
    Object? dataManagement = null,
    Object? conversation = null,
    Object? isRefreshing = null,
  }) {
    return _then(_value.copyWith(
      vocabularies: null == vocabularies
          ? _value.vocabularies
          : vocabularies // ignore: cast_nullable_to_non_nullable
              as VocabulariesState,
      phrases: null == phrases
          ? _value.phrases
          : phrases // ignore: cast_nullable_to_non_nullable
              as PhrasesState,
      analytics: null == analytics
          ? _value.analytics
          : analytics // ignore: cast_nullable_to_non_nullable
              as UserAnalyticsState,
      dataManagement: null == dataManagement
          ? _value.dataManagement
          : dataManagement // ignore: cast_nullable_to_non_nullable
              as UserDataManagementState,
      conversation: null == conversation
          ? _value.conversation
          : conversation // ignore: cast_nullable_to_non_nullable
              as ConversationState,
      isRefreshing: null == isRefreshing
          ? _value.isRefreshing
          : isRefreshing // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  /// Create a copy of DailyLessonsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VocabulariesStateCopyWith<$Res> get vocabularies {
    return $VocabulariesStateCopyWith<$Res>(_value.vocabularies, (value) {
      return _then(_value.copyWith(vocabularies: value) as $Val);
    });
  }

  /// Create a copy of DailyLessonsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PhrasesStateCopyWith<$Res> get phrases {
    return $PhrasesStateCopyWith<$Res>(_value.phrases, (value) {
      return _then(_value.copyWith(phrases: value) as $Val);
    });
  }

  /// Create a copy of DailyLessonsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserAnalyticsStateCopyWith<$Res> get analytics {
    return $UserAnalyticsStateCopyWith<$Res>(_value.analytics, (value) {
      return _then(_value.copyWith(analytics: value) as $Val);
    });
  }

  /// Create a copy of DailyLessonsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDataManagementStateCopyWith<$Res> get dataManagement {
    return $UserDataManagementStateCopyWith<$Res>(_value.dataManagement,
        (value) {
      return _then(_value.copyWith(dataManagement: value) as $Val);
    });
  }

  /// Create a copy of DailyLessonsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ConversationStateCopyWith<$Res> get conversation {
    return $ConversationStateCopyWith<$Res>(_value.conversation, (value) {
      return _then(_value.copyWith(conversation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$DailyLessonsStateImplCopyWith<$Res>
    implements $DailyLessonsStateCopyWith<$Res> {
  factory _$$DailyLessonsStateImplCopyWith(_$DailyLessonsStateImpl value,
          $Res Function(_$DailyLessonsStateImpl) then) =
      __$$DailyLessonsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {VocabulariesState vocabularies,
      PhrasesState phrases,
      UserAnalyticsState analytics,
      UserDataManagementState dataManagement,
      ConversationState conversation,
      bool isRefreshing});

  @override
  $VocabulariesStateCopyWith<$Res> get vocabularies;
  @override
  $PhrasesStateCopyWith<$Res> get phrases;
  @override
  $UserAnalyticsStateCopyWith<$Res> get analytics;
  @override
  $UserDataManagementStateCopyWith<$Res> get dataManagement;
  @override
  $ConversationStateCopyWith<$Res> get conversation;
}

/// @nodoc
class __$$DailyLessonsStateImplCopyWithImpl<$Res>
    extends _$DailyLessonsStateCopyWithImpl<$Res, _$DailyLessonsStateImpl>
    implements _$$DailyLessonsStateImplCopyWith<$Res> {
  __$$DailyLessonsStateImplCopyWithImpl(_$DailyLessonsStateImpl _value,
      $Res Function(_$DailyLessonsStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of DailyLessonsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vocabularies = null,
    Object? phrases = null,
    Object? analytics = null,
    Object? dataManagement = null,
    Object? conversation = null,
    Object? isRefreshing = null,
  }) {
    return _then(_$DailyLessonsStateImpl(
      vocabularies: null == vocabularies
          ? _value.vocabularies
          : vocabularies // ignore: cast_nullable_to_non_nullable
              as VocabulariesState,
      phrases: null == phrases
          ? _value.phrases
          : phrases // ignore: cast_nullable_to_non_nullable
              as PhrasesState,
      analytics: null == analytics
          ? _value.analytics
          : analytics // ignore: cast_nullable_to_non_nullable
              as UserAnalyticsState,
      dataManagement: null == dataManagement
          ? _value.dataManagement
          : dataManagement // ignore: cast_nullable_to_non_nullable
              as UserDataManagementState,
      conversation: null == conversation
          ? _value.conversation
          : conversation // ignore: cast_nullable_to_non_nullable
              as ConversationState,
      isRefreshing: null == isRefreshing
          ? _value.isRefreshing
          : isRefreshing // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$DailyLessonsStateImpl implements _DailyLessonsState {
  const _$DailyLessonsStateImpl(
      {required this.vocabularies,
      required this.phrases,
      required this.analytics,
      required this.dataManagement,
      required this.conversation,
      this.isRefreshing = false});

  @override
  final VocabulariesState vocabularies;
  @override
  final PhrasesState phrases;
  @override
  final UserAnalyticsState analytics;
  @override
  final UserDataManagementState dataManagement;
  @override
  final ConversationState conversation;
  @override
  @JsonKey()
  final bool isRefreshing;

  @override
  String toString() {
    return 'DailyLessonsState(vocabularies: $vocabularies, phrases: $phrases, analytics: $analytics, dataManagement: $dataManagement, conversation: $conversation, isRefreshing: $isRefreshing)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DailyLessonsStateImpl &&
            (identical(other.vocabularies, vocabularies) ||
                other.vocabularies == vocabularies) &&
            (identical(other.phrases, phrases) || other.phrases == phrases) &&
            (identical(other.analytics, analytics) ||
                other.analytics == analytics) &&
            (identical(other.dataManagement, dataManagement) ||
                other.dataManagement == dataManagement) &&
            (identical(other.conversation, conversation) ||
                other.conversation == conversation) &&
            (identical(other.isRefreshing, isRefreshing) ||
                other.isRefreshing == isRefreshing));
  }

  @override
  int get hashCode => Object.hash(runtimeType, vocabularies, phrases, analytics,
      dataManagement, conversation, isRefreshing);

  /// Create a copy of DailyLessonsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DailyLessonsStateImplCopyWith<_$DailyLessonsStateImpl> get copyWith =>
      __$$DailyLessonsStateImplCopyWithImpl<_$DailyLessonsStateImpl>(
          this, _$identity);
}

abstract class _DailyLessonsState implements DailyLessonsState {
  const factory _DailyLessonsState(
      {required final VocabulariesState vocabularies,
      required final PhrasesState phrases,
      required final UserAnalyticsState analytics,
      required final UserDataManagementState dataManagement,
      required final ConversationState conversation,
      final bool isRefreshing}) = _$DailyLessonsStateImpl;

  @override
  VocabulariesState get vocabularies;
  @override
  PhrasesState get phrases;
  @override
  UserAnalyticsState get analytics;
  @override
  UserDataManagementState get dataManagement;
  @override
  ConversationState get conversation;
  @override
  bool get isRefreshing;

  /// Create a copy of DailyLessonsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DailyLessonsStateImplCopyWith<_$DailyLessonsStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
